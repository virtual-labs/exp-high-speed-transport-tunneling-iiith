<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Semiconductor Diode Transport Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f8fafc, #e2e8f0);
            color: #1f2937;
            height: 100vh;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }

        .container {
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 0.5rem;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        .header {
            text-align: center;
            margin-bottom: 0.5rem;
            position: relative;
            flex-shrink: 0;
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.3rem;
        }

        .header p {
            font-size: 0.9rem;
            color: #6b7280;
            font-weight: 300;
        }

        .nav-tabs {
            display: flex;
            background: white;
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 0.5rem;
            margin-bottom: 1rem;
            border: 1px solid #e5e7eb;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }

        .nav-tab {
            flex: 1;
            padding: 0.8rem 1rem;
            text-align: center;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 500;
            border: none;
            background: transparent;
            color: #6b7280;
            position: relative;
            overflow: hidden;
            font-size: 0.9rem;
        }

        .nav-tab::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(99, 102, 241, 0.1), transparent);
            transition: left 0.5s;
        }

        .nav-tab:hover::before {
            left: 100%;
        }

        .nav-tab.active {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(99, 102, 241, 0.3);
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease-in-out;
            flex: 1;
            overflow-y: auto;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .card {
            background: white;
            backdrop-filter: blur(15px);
            border: 1px solid #e5e7eb;
            border-radius: 20px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            flex: 1;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(99, 102, 241, 0.3), transparent);
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
            border-color: rgba(99, 102, 241, 0.3);
        }

        .grid {
            display: grid;
            gap: 1rem;
        }

        .grid-2 {
            grid-template-columns: 1fr 1fr;
        }

        .controls-panel {
            background: white;
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid #e5e7eb;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .control-group {
            margin-bottom: 1.5rem;
        }

        .control-label {
            display: block;
            font-weight: 500;
            margin-bottom: 0.75rem;
            color: #1f2937;
            font-size: 0.9rem;
        }

        .slider-container {
            position: relative;
            margin: 1rem 0;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e5e7eb;
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(99, 102, 241, 0.5);
            transition: all 0.2s;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.7);
        }

        .slider-value {
            position: absolute;
            right: 0;
            top: -25px;
            color: #6366f1;
            font-weight: 600;
            font-size: 1.1rem;
            font-feature-settings: "sups" 1;
            -webkit-font-feature-settings: "sups" 1;
        }

        .slider-value sup {
            font-size: 0.8em;
            vertical-align: super;
            line-height: 0;
            font-weight: 600;
            letter-spacing: 0px;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin: 0.25rem;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:active::before {
            width: 300px;
            height: 300px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(99, 102, 241, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #e879f9 0%, #c084fc 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(232, 121, 249, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
        }

        .status-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .status-item {
            text-align: center;
            padding: 1.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            position: relative;
            overflow: hidden;
        }

        .status-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: left 0.5s ease-in-out;
        }

        .status-item:hover::before {
            left: 0;
        }

        .status-label {
            display: block;
            font-size: 0.8rem;
            font-weight: 500;
            color: #a0aec0;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }

        .status-value {
            display: block;
            font-size: 1.2rem;
            font-weight: 700;
            color: #667eea;
            word-break: break-all;
            line-height: 1.1;
        }

        .chart-container {
            position: relative;
            height: 300px;
            background: #f8fafc;
            border-radius: 15px;
            padding: 1rem;
            border: 1px solid #e5e7eb;
        }

        .tunneling-visualization {
            width: 100%;
            height: 320px;
            position: relative;
            background: linear-gradient(135deg, #f8fafc, #e2e8f0);
            border-radius: 20px;
            overflow: hidden;
            border: 1px solid #e5e7eb;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .visualization-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            display: flex;
            gap: 10px;
        }

        .viz-tab {
            padding: 8px 16px;
            background: rgba(248, 250, 252, 0.9);
            border: 1px solid #e5e7eb;
            border-radius: 20px;
            color: #374151;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }

        .viz-tab:hover {
            background: rgba(99, 102, 241, 0.1);
            border-color: #6366f1;
        }

        .viz-tab.active {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            border-color: #6366f1;
            color: white;
        }

        .energy-scale {
            position: absolute;
            left: 10px;
            top: 50px;
            bottom: 50px;
            width: 30px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            font-size: 11px;
            color: #6b7280;
        }

        @media (max-width: 768px) {
            .grid-2 {
                grid-template-columns: 1fr;
            }
            
            .nav-tabs {
                flex-direction: column;
            }
            
            .container {
                padding: 0.5rem;
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
            
            .chart-container {
                height: 250px;
            }
            
            .tunneling-visualization {
                height: 250px;
            }
        }

        .glow {
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { box-shadow: 0 0 5px rgba(99, 102, 241, 0.2); }
            to { box-shadow: 0 0 20px rgba(99, 102, 241, 0.5); }
        }

        .pulse {
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(99, 102, 241, 0.3);
            border-left-color: #6366f1;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">


        <div class="nav-tabs">
            <button class="nav-tab active" data-tab="quantum-tunneling">
                Quantum Tunneling
            </button>
            <button class="nav-tab" data-tab="transport-comparison">
                Transport Comparison
            </button>
            <button class="nav-tab" data-tab="impatt-dynamics">
                IMPATT Dynamics
            </button>
            <button class="nav-tab" data-tab="challenges">
                Challenges
            </button>
        </div>

        <!-- Quantum Tunneling Tab -->
        <div id="quantum-tunneling" class="tab-content active">
            <div class="grid grid-2">
                <div class="card">
                    <h3>Quantum Tunneling Parameters</h3>
                    <div class="controls-panel">
                        
                        <!-- Preset Buttons -->
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 20px;">
                            <button class="btn btn-primary" onclick="applyTunnelingPreset('balanced')">
                                ⚖️ Balanced
                            </button>
                            <button class="btn btn-secondary" onclick="applyTunnelingPreset('thin_barrier')">
                                📏 Thin Barrier
                            </button>
                            <button class="btn btn-success" onclick="applyTunnelingPreset('high_field')">
                                ⚡ High Field
                            </button>
                            <button class="btn btn-primary" onclick="applyTunnelingPreset('low_temp')">
                                🧊 Low Temperature
                            </button>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Applied Voltage (V)</label>
                            <div class="slider-container">
                                <input type="range" id="tunnelingVoltage" class="slider" min="-0.8" max="1.2" step="0.01" value="0.3">
                                <span class="slider-value" id="tunnelingVoltageValue">0.3 V</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Barrier Width (nm)</label>
                            <div class="slider-container">
                                <input type="range" id="barrierWidth" class="slider" min="0.5" max="15" step="0.1" value="2.5">
                                <span class="slider-value" id="barrierWidthValue">2.5 nm</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Barrier Height (eV)</label>
                            <div class="slider-container">
                                <input type="range" id="barrierHeight" class="slider" min="0.05" max="3.0" step="0.02" value="0.65">
                                <span class="slider-value" id="barrierHeightValue">0.65 eV</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Temperature (K)</label>
                            <div class="slider-container">
                                <input type="range" id="temperature" class="slider" min="4" max="500" step="5" value="300">
                                <span class="slider-value" id="temperatureValue">300 K</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Effective Mass (m₀)</label>
                            <div class="slider-container">
                                <input type="range" id="effectiveMass" class="slider" min="0.01" max="1.0" step="0.001" value="0.067">
                                <span class="slider-value" id="effectiveMassValue">0.067 m₀</span>
                            </div>
                        </div>
                        
                        <div style="display: flex; gap: 10px; margin-top: 20px;">
                            <button class="btn btn-primary" onclick="startTunnelingAnimation()">
                                🌊 Start Animation
                            </button>
                            <button class="btn btn-secondary" onclick="calculateTransmission()">
                                📊 Calculate T(E)
                            </button>
                            <button class="btn btn-success" onclick="resetTunneling()">
                                🔄 Reset
                            </button>
                        </div>
                    </div>
                    
                    <div class="status-display">
                        <div class="status-item">
                            <span class="status-label">Transmission Probability</span>
                            <span class="status-value" id="transmissionProb">0.85 %</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Transit Time</span>
                            <span class="status-value" id="transitTime">0.15 fs</span>
                        </div>
                    </div>
                </div>

                <div class="card" style="display: flex; flex-direction: column;">
                    <div style="flex: 1; margin-bottom: 0.5rem;">
                        <h3>Quantum Band Diagram</h3>
                        <div class="tunneling-visualization" id="tunnelingViz" style="height: 440px;">
                            <div class="visualization-controls">
                                <div class="viz-tab active" onclick="switchVisualization('band-diagram')">Band Diagram</div>
                                <div class="viz-tab" onclick="switchVisualization('wave-function')">Wave Function</div>
                                <div class="viz-tab" onclick="switchVisualization('probability')">Probability Density</div>
                            </div>
                            
                            <div class="energy-scale">
                                <div>2.0</div>
                                <div>1.5</div>
                                <div>1.0</div>
                                <div>0.5</div>
                                <div>0.0</div>
                                <div>-0.5</div>
                            </div>
                            
                            <canvas id="tunnelingCanvas" width="1000" height="700"></canvas>
                        </div>
                    </div>
                    
                    <div style="flex: 1; margin-top: 0.5rem;">
                        <h3>Transmission Coefficient Analysis</h3>
                        <div class="chart-container" style="height: 320px; width: 100%; padding: 10px; box-sizing: border-box;">
                            <div id="transmissionChart" class="plot-container" style="width: 100%; height: 100%;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Transport Comparison Tab -->
        <div id="transport-comparison" class="tab-content">
            <div class="grid grid-2">
                <div class="card">
                    <h3>Transport Mechanism Controls</h3>
                    <div class="controls-panel">
                        
                        <!-- Preset Buttons -->
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 20px;">
                            <button class="btn btn-primary" onclick="applyTransportPreset('fast_pulse')">
                                ⚡ Fast Pulse
                            </button>
                            <button class="btn btn-secondary" onclick="applyTransportPreset('slow_ramp')">
                                📈 Slow Ramp
                            </button>
                            <button class="btn btn-success" onclick="applyTransportPreset('step_response')">
                                📊 Step Response
                            </button>
                            <button class="btn btn-primary" onclick="applyTransportPreset('high_field')">
                                🔥 High Field
                            </button>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Pulse Amplitude (V)</label>
                            <div class="slider-container">
                                <input type="range" id="pulseAmplitude" class="slider" min="0.1" max="3.0" step="0.1" value="1.2">
                                <span class="slider-value" id="pulseAmplitudeValue">1.2 V</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Rise Time (ps)</label>
                            <div class="slider-container">
                                <input type="range" id="riseTime" class="slider" min="0.5" max="200" step="0.5" value="5">
                                <span class="slider-value" id="riseTimeValue">5 ps</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Device Length (nm)</label>
                            <div class="slider-container">
                                <input type="range" id="deviceLength" class="slider" min="10" max="1000" step="10" value="200">
                                <span class="slider-value" id="deviceLengthValue">200 nm</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Doping Level (cm⁻³)</label>
                            <div class="slider-container">
                                <input type="range" id="dopingLevel" class="slider" min="16" max="20" step="1" value="18">
                                <span class="slider-value" id="dopingLevelValue">10¹⁸ cm⁻³</span>
                            </div>
                        </div>
                        
                        <div style="display: flex; gap: 10px; margin-top: 20px;">
                            <button class="btn btn-primary" onclick="runTransportComparison()">
                                🔄 Compare Mechanisms
                            </button>
                            <button class="btn btn-secondary" onclick="startCarrierDynamicsVisualization()">
                                🎬 Start Animation
                            </button>
                        </div>
                    </div>
                    
                    <div class="status-display">
                        <div class="status-item">
                            <span class="status-label">Drift Transit Time</span>
                            <span class="status-value" id="driftTime">45 ps</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Tunnel Transit Time</span>
                            <span class="status-value" id="tunnelTime">0.8 ps</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Speed Advantage</span>
                            <span class="status-value" id="speedRatio">56x</span>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h3>Carrier Dynamics Visualization</h3>
                    <div class="tunneling-visualization" style="height: 350px; margin-bottom: 20px;">
                        <canvas id="carrierCanvas"></canvas>
                    </div>
                    
                    <h3 style="margin-top: 20px; margin-bottom: 15px;">Transient Response Comparison</h3>
                    <div class="chart-container" style="height: 350px; width: 100%; padding: 15px; box-sizing: border-box; background: #ffffff; border-radius: 8px; border: 1px solid #e5e7eb;">
                        <div id="responseChart" class="plot-container" style="width: 100%; height: 100%;"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- IMPATT Dynamics Tab -->
        <div id="impatt-dynamics" class="tab-content">
            <div class="grid grid-2">
                <div class="card">
                    <h3>IMPATT Oscillator Parameters</h3>
                    <div class="controls-panel">
                        
                        <!-- Preset Buttons -->
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 20px;">
                            <button class="btn btn-primary" onclick="applyImpattPreset('x_band')">
                                📡 X-Band (10 GHz)
                            </button>
                            <button class="btn btn-secondary" onclick="applyImpattPreset('ku_band')">
                                🛰️ Ku-Band (15 GHz)
                            </button>
                            <button class="btn btn-success" onclick="applyImpattPreset('ka_band')">
                                🚀 Ka-Band (35 GHz)
                            </button>
                            <button class="btn btn-primary" onclick="applyImpattPreset('low_power')">
                                🔋 Low Power
                            </button>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Bias Voltage (V)</label>
                            <div class="slider-container">
                                <input type="range" id="impattBias" class="slider" min="5" max="150" step="1" value="45">
                                <span class="slider-value" id="impattBiasValue">45 V</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">RF Frequency (GHz)</label>
                            <div class="slider-container">
                                <input type="range" id="impattFreq" class="slider" min="0.5" max="100" step="0.5" value="12">
                                <span class="slider-value" id="impattFreqValue">12 GHz</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Drift Length (μm)</label>
                            <div class="slider-container">
                                <input type="range" id="driftLength" class="slider" min="0.5" max="20" step="0.1" value="5">
                                <span class="slider-value" id="driftLengthValue">5 μm</span>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label class="control-label">Load Resistance (Ω)</label>
                            <div class="slider-container">
                                <input type="range" id="loadResistance" class="slider" min="1" max="100" step="1" value="25">
                                <span class="slider-value" id="loadResistanceValue">25 Ω</span>
                            </div>
                        </div>
                        
                        <div style="display: flex; gap: 10px; margin-top: 20px;">
                            <button class="btn btn-primary" onclick="startImpattOscillation()">
                                ⚡ Start Oscillation
                            </button>
                            <button class="btn btn-secondary" onclick="stopImpattOscillation()">
                                ⏹️ Stop
                            </button>
                        </div>
                    </div>
                    
                    <div class="status-display">
                        <div class="status-item">
                            <span class="status-label">Output Power</span>
                            <span class="status-value" id="impattPower">125 mW</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Efficiency</span>
                            <span class="status-value" id="impattEfficiency">18.5 %</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Q Factor</span>
                            <span class="status-value" id="qFactor">85</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Phase Noise</span>
                            <span class="status-value" id="phaseNoise">-85 dBc</span>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h3>Avalanche Multiplication Dynamics</h3>
                    <div class="tunneling-visualization" style="height: 450px; margin-bottom: 20px;">
                        <canvas id="impattCanvas" style="width: 100%; height: 100%;"></canvas>
                    </div>
                    
                    <div style="display: flex; flex-direction: column; gap: 30px;">
                        <div>
                            <h3 style="margin-bottom: 15px;">Time Domain Response</h3>
                            <div class="chart-container" style="height: 250px; background: #ffffff; border-radius: 8px; border: 1px solid #e5e7eb; padding: 10px;">
                                <div id="impattTimeChart" class="plot-container" style="width: 100%; height: 100%;"></div>
                            </div>
                        </div>
                        
                        <div>
                            <h3 style="margin-bottom: 15px;">Power Spectrum Analysis</h3>
                            <div class="chart-container" style="height: 250px; background: #ffffff; border-radius: 8px; border: 1px solid #e5e7eb; padding: 10px;">
                                <div id="impattSpectrumChart" class="plot-container" style="width: 100%; height: 100%;"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Challenges Tab -->
        <div id="challenges" class="tab-content">
            <div class="challenge-container">
                <div class="challenge-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="totalScoreValue">0</div>
                        <div class="stat-label">Total Score</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="challengesCompletedValue">0/4</div>
                        <div class="stat-label">Challenges Completed</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="hintsUsedValue">0</div>
                        <div class="stat-label">Hints Used</div>
                    </div>
                </div>

                <div class="challenge-progress">
                    <div class="challenge-progress-bar" id="totalProgressBar" style="width: 0%;"></div>
                </div>

                <!-- Challenge 1: Basic MCQs -->
                <div class="challenge-section" id="challenge1">
                    <div class="challenge-header">
                        <div class="challenge-icon">
                            <i class="fas fa-question-circle"></i>
                        </div>
                        <h3 class="challenge-title">Quantum Tunneling Fundamentals</h3>
                    </div>
                    <p class="challenge-description">Test your understanding of quantum tunneling concepts with these multiple-choice questions.</p>
                    
                    <div id="challenge1-content"></div>
                    
                    <div class="challenge-controls">
                        <button class="challenge-btn challenge-btn-primary" onclick="checkQuizAnswers(1)">Submit Answers</button>
                        <button class="challenge-btn challenge-btn-secondary" onclick="showQuizHints(1)">Hint</button>
                        <button class="challenge-btn challenge-btn-secondary" onclick="resetChallenge(1)">Reset</button>
                    </div>
                    <div class="challenge-feedback" id="challenge1-feedback"></div>
                </div>

                <!-- Challenge 2: Advanced Concepts -->
                <div class="challenge-section" id="challenge2">
                    <div class="challenge-header">
                        <div class="challenge-icon">
                            <i class="fas fa-atom"></i>
                        </div>
                        <h3 class="challenge-title">Advanced Semiconductor Transport</h3>
                    </div>
                    <p class="challenge-description">Demonstrate your advanced understanding of carrier transport mechanisms in semiconductor devices.</p>
                    
                    <div id="challenge2-content"></div>
                    
                    <div class="challenge-controls">
                        <button class="challenge-btn challenge-btn-primary" onclick="checkAdvancedAnswers()">Submit Answers</button>
                        <button class="challenge-btn challenge-btn-secondary" onclick="showAdvancedHints()">Hint</button>
                        <button class="challenge-btn challenge-btn-secondary" onclick="resetChallenge(2)">Reset</button>
                    </div>
                    <div class="challenge-feedback" id="challenge2-feedback"></div>
                </div>

                <!-- Challenge 3: Fill in the Blanks -->
                <div class="challenge-section" id="challenge3">
                    <div class="challenge-header">
                        <div class="challenge-icon">
                            <i class="fas fa-edit"></i>
                        </div>
                        <h3 class="challenge-title">Complete the Concepts</h3>
                    </div>
                    <p class="challenge-description">Fill in the missing terms in these semiconductor device statements.</p>
                    
                    <div id="challenge3-content"></div>
                    
                    <div class="challenge-controls">
                        <button class="challenge-btn challenge-btn-primary" onclick="checkFillBlanks()">Submit Answers</button>
                        <button class="challenge-btn challenge-btn-secondary" onclick="showFillBlanksHint()">Hint</button>
                        <button class="challenge-btn challenge-btn-secondary" onclick="resetChallenge(3)">Reset</button>
                    </div>
                    <div class="challenge-feedback" id="challenge3-feedback"></div>
                </div>

                <!-- Challenge 4: Numerical Problems -->
                <div class="challenge-section" id="challenge4">
                    <div class="challenge-header">
                        <div class="challenge-icon">
                            <i class="fas fa-calculator"></i>
                        </div>
                        <h3 class="challenge-title">Quantum Device Calculations</h3>
                    </div>
                    <p class="challenge-description">Solve these numerical problems related to semiconductor device physics.</p>
                    
                    <div id="challenge4-content"></div>
                    
                    <div class="challenge-controls">
                        <button class="challenge-btn challenge-btn-primary" onclick="checkCalculations()">Submit Answers</button>
                        <button class="challenge-btn challenge-btn-secondary" onclick="showCalculationHint()">Hint</button>
                        <button class="challenge-btn challenge-btn-secondary" onclick="resetChallenge(4)">Reset</button>
                    </div>
                    <div class="challenge-feedback" id="challenge4-feedback"></div>
                </div>

                <!-- Reset All Button -->
                <div style="text-align: center; margin-top: 30px; margin-bottom: 20px;">
                    <button class="btn-danger" onclick="resetAllChallenges()">
                        <i class="fas fa-sync-alt"></i> Reset All Challenges
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentVisualization = 'band-diagram';
        let tunnelingAnimationId = null;
        let carrierAnimationId = null;
        let impattAnimationId = null;
        let isImpattRunning = false;
        let particles = [];
        let waveFunction = [];
        let transmissionData = [];
        let avalancheParticles = [];
        let impactEvents = [];

        // Physical constants
        const CONSTANTS = {
            h: 6.626e-34,
            hbar: 1.055e-34,
            q: 1.602e-19,
            me: 9.109e-31,
            k: 1.38e-23,
            c: 2.998e8
        };

        // Preset configurations
        const tunnelingPresets = {
            balanced: { voltage: 0.3, width: 2.5, height: 0.65, temp: 300, mass: 0.067 },
            thin_barrier: { voltage: 0.2, width: 1.0, height: 0.5, temp: 300, mass: 0.067 },
            high_field: { voltage: 0.8, width: 3.0, height: 1.2, temp: 300, mass: 0.067 },
            low_temp: { voltage: 0.3, width: 2.5, height: 0.65, temp: 77, mass: 0.067 }
        };

        const transportPresets = {
            fast_pulse: { amplitude: 1.5, riseTime: 2, length: 100, doping: 18 },
            slow_ramp: { amplitude: 0.8, riseTime: 50, length: 500, doping: 17 },
            step_response: { amplitude: 1.0, riseTime: 10, length: 200, doping: 18 },
            high_field: { amplitude: 2.5, riseTime: 1, length: 50, doping: 19 }
        };

        const impattPresets = {
            x_band: { bias: 45, freq: 10, drift: 5, resistance: 25 },
            ku_band: { bias: 60, freq: 15, drift: 3, resistance: 20 },
            ka_band: { bias: 80, freq: 35, drift: 1.5, resistance: 15 },
            low_power: { bias: 25, freq: 8, drift: 8, resistance: 50 }
        };

        // Initialize application
        document.addEventListener('DOMContentLoaded', function() {
            initializeCharts();
            updateAllControls();
            setupEventListeners();
            initializeTunnelingVisualization();
            
            // Initialize charts with default values
            setTimeout(() => {
                calculateTransmission();
                runTransportComparison();
                initializeCarrierCanvas();
                initializeImpattCanvas();
                
                // Welcome popup removed as requested
                
            }, 500);
        });

        window.addEventListener('resize', function() {
            setTimeout(() => {
                initializeCarrierCanvas();
                initializeImpattCanvas();
                if (typeof Plotly !== 'undefined') {
                    Plotly.Plots.resize('transmissionChart');
                    Plotly.Plots.resize('responseChart');
                    Plotly.Plots.resize('impattTimeChart');
                    Plotly.Plots.resize('impattSpectrumChart');
                }
            }, 100);
        });

        function initializeCharts() {
            if (typeof Plotly === 'undefined') {
                console.error('Plotly not loaded');
                return;
            }

            const commonLayout = {
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: '#f8fafc',
                font: { color: '#374151', family: 'Inter', size: 12 },
                showlegend: true,
                margin: { t: 40, r: 40, b: 60, l: 60 },
                grid: { color: 'rgba(107,114,128,0.2)' }
            };

            Plotly.newPlot('transmissionChart', [], {
                ...commonLayout,
                title: { text: 'Transmission Probability vs Energy', font: { size: 16 } },
                margin: { t: 50, r: 50, b: 80, l: 80 },
                xaxis: { 
                    title: { 
                        text: 'Energy (eV)',
                        font: { size: 16, color: '#374151', family: 'Inter' },
                        standoff: 20
                    }, 
                    gridcolor: 'rgba(107,114,128,0.2)',
                    showgrid: true,
                    zeroline: false,
                    tickfont: { size: 14, color: '#374151', family: 'Inter' },
                    showline: true,
                    linecolor: '#374151',
                    linewidth: 1
                },
                yaxis: { 
                    title: { 
                        text: 'Transmission T(E)',
                        font: { size: 16, color: '#374151', family: 'Inter' },
                        standoff: 20
                    }, 
                    gridcolor: 'rgba(107,114,128,0.2)',
                    showgrid: true,
                    zeroline: false,
                    range: [0, 1],
                    tickfont: { size: 14, color: '#374151', family: 'Inter' },
                    showline: true,
                    linecolor: '#374151',
                    linewidth: 1
                },
                font: { 
                    family: 'Inter, Arial, sans-serif', 
                    size: 14, 
                    color: '#374151' 
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: '#ffffff'
            }, { responsive: true });

            Plotly.newPlot('responseChart', [], {
                ...commonLayout,
                title: { text: 'Current Response Comparison', font: { size: 16 } },
                xaxis: { 
                    title: 'Time (ps)', 
                    gridcolor: 'rgba(107,114,128,0.2)',
                    showgrid: true
                },
                yaxis: { 
                    title: 'Current (mA)', 
                    gridcolor: 'rgba(107,114,128,0.2)',
                    showgrid: true
                }
            }, { responsive: true });

            Plotly.newPlot('impattTimeChart', [], {
                ...commonLayout,
                title: { text: 'IMPATT Current Oscillations', font: { size: 16 } },
                margin: { t: 50, r: 40, b: 60, l: 60 },
                showlegend: true,
                xaxis: { 
                    title: { text: 'Time (ns)', font: { size: 14 } },
                    gridcolor: 'rgba(107,114,128,0.2)',
                    showgrid: true,
                    tickfont: { size: 12 }
                },
                yaxis: { 
                    title: { text: 'Current (mA)', font: { size: 14 } },
                    gridcolor: 'rgba(107,114,128,0.2)',
                    showgrid: true,
                    tickfont: { size: 12 }
                }
            }, { responsive: true });

            Plotly.newPlot('impattSpectrumChart', [], {
                ...commonLayout,
                title: { text: 'Power Spectral Density', font: { size: 16 } },
                margin: { t: 50, r: 40, b: 60, l: 60 },
                showlegend: true,
                xaxis: { 
                    title: { text: 'Frequency (GHz)', font: { size: 14 } },
                    gridcolor: 'rgba(107,114,128,0.2)',
                    showgrid: true,
                    tickfont: { size: 12 }
                },
                yaxis: { 
                    title: { text: 'Power (dBm)', font: { size: 14 } },
                    gridcolor: 'rgba(107,114,128,0.2)',
                    showgrid: true,
                    tickfont: { size: 12 }
                }
            }, { responsive: true });
        }

        function updateAllControls() {
            const sliders = [
                { id: 'tunnelingVoltage', valueId: 'tunnelingVoltageValue', suffix: ' V', precision: 2 },
                { id: 'barrierWidth', valueId: 'barrierWidthValue', suffix: ' nm', precision: 1 },
                { id: 'barrierHeight', valueId: 'barrierHeightValue', suffix: ' eV', precision: 2 },
                { id: 'temperature', valueId: 'temperatureValue', suffix: ' K', precision: 0 },
                { id: 'effectiveMass', valueId: 'effectiveMassValue', suffix: ' m₀', precision: 3 },
                { id: 'pulseAmplitude', valueId: 'pulseAmplitudeValue', suffix: ' V', precision: 1 },
                { id: 'riseTime', valueId: 'riseTimeValue', suffix: ' ps', precision: 1 },
                { id: 'deviceLength', valueId: 'deviceLengthValue', suffix: ' nm', precision: 0 },
                { id: 'dopingLevel', valueId: 'dopingLevelValue', prefix: '10', suffix: ' cm⁻³', precision: 0, superscript: true },
                { id: 'impattBias', valueId: 'impattBiasValue', suffix: ' V', precision: 0 },
                { id: 'impattFreq', valueId: 'impattFreqValue', suffix: ' GHz', precision: 1 },
                { id: 'driftLength', valueId: 'driftLengthValue', suffix: ' μm', precision: 1 },
                { id: 'loadResistance', valueId: 'loadResistanceValue', suffix: ' Ω', precision: 0 }
            ];

            sliders.forEach(slider => {
                const element = document.getElementById(slider.id);
                const valueElement = document.getElementById(slider.valueId);
                if (element && valueElement) {
                    let value = parseFloat(element.value);
                    let displayValue = value.toFixed(slider.precision);
                    
                    if (slider.superscript) {
                        displayValue = slider.prefix + formatSuperscript(displayValue) + slider.suffix;
                    } else {
                        displayValue = (slider.prefix || '') + displayValue + slider.suffix;
                    }
                    
                    valueElement.innerHTML = displayValue;
                }
            });
        }

        function formatSuperscript(value) {
            return '<sup>' + value.toString() + '</sup>';
        }

        function setupEventListeners() {
            document.querySelectorAll('.slider').forEach(slider => {
                slider.addEventListener('input', function() {
                    updateAllControls();
                    updateTunnelingCalculations();
                    updateTransportCalculations();
                    updateImpattCalculations();
                    
                    clearTimeout(window.chartUpdateTimeout);
                    window.chartUpdateTimeout = setTimeout(() => {
                        try {
                            calculateTransmission();
                            runTransportComparison();
                        } catch (error) {
                            console.log('Chart update error:', error);
                        }
                    }, 100);
                    
                    if (currentVisualization && tunnelingAnimationId) {
                        updateTunnelingVisualization();
                    }
                });
            });
            
            const transportSliders = ['pulseAmplitude', 'riseTime', 'deviceLength', 'dopingLevel'];
            transportSliders.forEach(sliderId => {
                const slider = document.getElementById(sliderId);
                if (slider) {
                    slider.addEventListener('input', function() {
                        clearTimeout(window.transportUpdateTimeout);
                        window.transportUpdateTimeout = setTimeout(() => {
                            try {
                                runTransportComparison();
                            } catch (error) {
                                console.log('Transport chart update error:', error);
                            }
                        }, 50);
                    });
                }
            });
            
            const tunnelingSliders = ['tunnelingVoltage', 'barrierWidth', 'barrierHeight', 'temperature', 'effectiveMass'];
            tunnelingSliders.forEach(sliderId => {
                const slider = document.getElementById(sliderId);
                if (slider) {
                    slider.addEventListener('input', function() {
                        clearTimeout(window.tunnelingUpdateTimeout);
                        window.tunnelingUpdateTimeout = setTimeout(() => {
                            try {
                                calculateTransmission();
                            } catch (error) {
                                console.log('Tunneling chart update error:', error);
                            }
                        }, 50);
                    });
                }
            });
        }

        function switchTab(event, tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active class from all nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show the selected tab content if it exists
            const tabContent = document.getElementById(tabName);
            if (tabContent) {
                tabContent.classList.add('active');
            }
            
            // Add active class to clicked button if event is provided
            if (event && event.currentTarget) {
                event.currentTarget.classList.add('active');
            }
            
            // Initialize challenges if the challenges tab is selected
            if (tabName === 'challenges') {
                initializeChallengesIfNeeded();
            }
            
            if (tabName === 'transport-comparison') {
                setTimeout(() => {
                    initializeCarrierCanvas();
                }, 100);
            } else if (tabName === 'impatt-dynamics') {
                setTimeout(() => {
                    initializeImpattCanvas();
                }, 100);
            } else if (tabName === 'challenges') {
                // Initialize challenges if this is the first time viewing this tab
                initializeChallengesIfNeeded();
            }
            
            setTimeout(() => {
                if (typeof Plotly !== 'undefined') {
                    Plotly.Plots.resize('transmissionChart');
                    Plotly.Plots.resize('responseChart');
                    Plotly.Plots.resize('impattTimeChart');
                    Plotly.Plots.resize('impattSpectrumChart');
                }
            }, 100);
        }

        function switchVisualization(vizType) {
            currentVisualization = vizType;
            
            document.querySelectorAll('.viz-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            updateTunnelingVisualization();
        }

        // Preset application functions
        function applyTunnelingPreset(presetName) {
            const preset = tunnelingPresets[presetName];
            if (!preset) return;

            document.getElementById('tunnelingVoltage').value = preset.voltage;
            document.getElementById('barrierWidth').value = preset.width;
            document.getElementById('barrierHeight').value = preset.height;
            document.getElementById('temperature').value = preset.temp;
            document.getElementById('effectiveMass').value = preset.mass;
            
            updateAllControls();
            updateTunnelingCalculations();
            updateTunnelingVisualization();
        }

        function applyTransportPreset(presetName) {
            const preset = transportPresets[presetName];
            if (!preset) return;

            document.getElementById('pulseAmplitude').value = preset.amplitude;
            document.getElementById('riseTime').value = preset.riseTime;
            document.getElementById('deviceLength').value = preset.length;
            document.getElementById('dopingLevel').value = preset.doping;
            
            updateAllControls();
            updateTransportCalculations();
        }

        function applyImpattPreset(presetName) {
            const preset = impattPresets[presetName];
            if (!preset) return;

            document.getElementById('impattBias').value = preset.bias;
            document.getElementById('impattFreq').value = preset.freq;
            document.getElementById('driftLength').value = preset.drift;
            document.getElementById('loadResistance').value = preset.resistance;
            
            updateAllControls();
            updateImpattCalculations();
        }

        function resetTunneling() {
            applyTunnelingPreset('balanced');
        }

        // Quantum tunneling calculations
        function updateTunnelingCalculations() {
            const tunnelingVoltageElement = document.getElementById('tunnelingVoltage');
            const barrierWidthElement = document.getElementById('barrierWidth');
            const barrierHeightElement = document.getElementById('barrierHeight');
            const temperatureElement = document.getElementById('temperature');
            const effectiveMassElement = document.getElementById('effectiveMass');
            
            if (!tunnelingVoltageElement || !barrierWidthElement || !barrierHeightElement || 
                !temperatureElement || !effectiveMassElement) {
                return;
            }
            
            const voltage = parseFloat(tunnelingVoltageElement.value);
            const width = parseFloat(barrierWidthElement.value) * 1e-9;
            const height = parseFloat(barrierHeightElement.value) * CONSTANTS.q;
            const temp = parseFloat(temperatureElement.value);
            const mass = parseFloat(effectiveMassElement.value) * CONSTANTS.me;

            const energy = Math.abs(voltage) * CONSTANTS.q;
            let transmission = 0;
            
            if (energy >= height) {
                transmission = 1.0;
            } else {
                const k = Math.sqrt(2 * mass * (height - energy)) / CONSTANTS.hbar;
                transmission = Math.exp(-2 * k * width);
            }
            
            const area = 1e-8;
            const currentDensity = (CONSTANTS.q * mass * Math.pow(voltage, 2)) / 
                                  (2 * Math.PI * Math.pow(CONSTANTS.hbar, 3)) * transmission;
            const current = currentDensity * area * 1000;

            const dos = Math.sqrt(2 * Math.pow(mass, 3) * energy) / (Math.PI * Math.pow(CONSTANTS.hbar, 3));
            const quantumCap = CONSTANTS.q * CONSTANTS.q * dos * area * 1e15;

            const velocity = Math.sqrt(2 * energy / mass);
            const transitTime = width / velocity * 1e15;

            const transmissionProbElement = document.getElementById('transmissionProb');
            const transitTimeElement = document.getElementById('transitTime');
            
            if (transmissionProbElement) {
                transmissionProbElement.textContent = (transmission * 100).toFixed(2) + ' %';
            }
            if (transitTimeElement) {
                transitTimeElement.textContent = transitTime.toFixed(2) + ' fs';
            }
        }

        function updateTransportCalculations() {
            const pulseAmplitudeElement = document.getElementById('pulseAmplitude');
            const riseTimeElement = document.getElementById('riseTime');
            const deviceLengthElement = document.getElementById('deviceLength');
            const dopingLevelElement = document.getElementById('dopingLevel');
            
            if (!pulseAmplitudeElement || !riseTimeElement || !deviceLengthElement || !dopingLevelElement) {
                return;
            }
            
            const amplitude = parseFloat(pulseAmplitudeElement.value);
            const riseTime = parseFloat(riseTimeElement.value) * 1e-12;
            const length = parseFloat(deviceLengthElement.value) * 1e-9;
            const doping = Math.pow(10, parseFloat(dopingLevelElement.value)) * 1e6;

            const mobility = 1400e-4 / (1 + Math.pow(doping / 1e23, 0.7));
            
            const electricField = amplitude / length;
            const driftVelocity = mobility * electricField;
            const driftTransitTime = length / driftVelocity * 1e12;

            const tunnelingVelocity = 1e8;
            const tunnelTransitTime = length / tunnelingVelocity * 1e12;

            const speedRatio = driftTransitTime / tunnelTransitTime;

            const driftTimeElement = document.getElementById('driftTime');
            const tunnelTimeElement = document.getElementById('tunnelTime');
            const speedRatioElement = document.getElementById('speedRatio');
            
            if (driftTimeElement) {
                driftTimeElement.textContent = driftTransitTime.toFixed(1) + ' ps';
            }
            if (tunnelTimeElement) {
                tunnelTimeElement.textContent = tunnelTransitTime.toFixed(1) + ' ps';
            }
            if (speedRatioElement) {
                speedRatioElement.textContent = speedRatio.toFixed(0) + 'x';
            }
        }

        function updateImpattCalculations() {
            const impattBiasElement = document.getElementById('impattBias');
            const impattFreqElement = document.getElementById('impattFreq');
            const driftLengthElement = document.getElementById('driftLength');
            const loadResistanceElement = document.getElementById('loadResistance');
            
            if (!impattBiasElement || !impattFreqElement || !driftLengthElement || !loadResistanceElement) {
                return;
            }
            
            const bias = parseFloat(impattBiasElement.value);
            const freq = parseFloat(impattFreqElement.value) * 1e9;
            const drift = parseFloat(driftLengthElement.value) * 1e-6;
            const resistance = parseFloat(loadResistanceElement.value);

            const transitTime = drift / 1e5;
            const optimalFreq = 1 / (2 * transitTime);
            
            const current = bias / (resistance + 10);
            const power = current * current * resistance;
            const powerMW = power * 1000;

            const dcPower = bias * current;
            const efficiency = (power / dcPower) * 100;

            const qFactor = 50 + 100 * Math.exp(-Math.abs(freq - optimalFreq) / (2e9));

            const phaseNoise = -70 - 10 * Math.log10(qFactor);

            const impattPowerElement = document.getElementById('impattPower');
            const impattEfficiencyElement = document.getElementById('impattEfficiency');
            const qFactorElement = document.getElementById('qFactor');
            const phaseNoiseElement = document.getElementById('phaseNoise');
            
            if (impattPowerElement) {
                impattPowerElement.textContent = powerMW.toFixed(0) + ' mW';
            }
            if (impattEfficiencyElement) {
                impattEfficiencyElement.textContent = efficiency.toFixed(1) + ' %';
            }
            if (qFactorElement) {
                qFactorElement.textContent = qFactor.toFixed(0);
            }
            if (phaseNoiseElement) {
                phaseNoiseElement.textContent = phaseNoise.toFixed(0) + ' dBc';
            }
        }

        // Visualization functions
        function initializeTunnelingVisualization() {
            const canvas = document.getElementById('tunnelingCanvas');
            if (!canvas) return;
            
            canvas.width = 1000;
            canvas.height = 700;
            updateTunnelingCalculations();
            updateTunnelingVisualization();
        }

        function updateTunnelingVisualization() {
            const canvas = document.getElementById('tunnelingCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            const voltage = parseFloat(document.getElementById('tunnelingVoltage').value);
            const barrierWidth = parseFloat(document.getElementById('barrierWidth').value);
            const barrierHeight = parseFloat(document.getElementById('barrierHeight').value);
            const temperature = parseFloat(document.getElementById('temperature').value);
            const effectiveMass = parseFloat(document.getElementById('effectiveMass').value);
            
            switch(currentVisualization) {
                case 'band-diagram':
                    drawQuantumBandDiagram(ctx, width, height, voltage, barrierWidth, barrierHeight, temperature);
                    break;
                case 'wave-function':
                    drawQuantumWaveFunction(ctx, width, height, voltage, barrierWidth, barrierHeight, effectiveMass);
                    break;
                case 'probability':
                    drawQuantumProbabilityDensity(ctx, width, height, voltage, barrierWidth, barrierHeight, effectiveMass);
                    break;
            }
        }

        function drawQuantumBandDiagram(ctx, width, height, voltage, barrierWidth, barrierHeight, temperature) {
            const bgGradient = ctx.createLinearGradient(0, 0, width, height);
            bgGradient.addColorStop(0, '#f8fafc');
            bgGradient.addColorStop(0.5, '#f1f5f9');
            bgGradient.addColorStop(1, '#e2e8f0');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, width, height);

            const energyScale = height * 0.6;
            const energyZero = height * 0.6;
            const eVtoPixels = 120;

            ctx.strokeStyle = 'rgba(148, 163, 184, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            
            for (let e = -1; e <= 3; e += 0.5) {
                const y = energyZero - e * eVtoPixels;
                if (y > 50 && y < height - 50) {
                    ctx.beginPath();
                    ctx.moveTo(80, y);
                    ctx.lineTo(width - 40, y);
                    ctx.stroke();
                    
                    if (e % 1 === 0) {
                        ctx.fillStyle = '#64748b';
                        ctx.font = '12px Inter';
                        ctx.fillText(`${e.toFixed(1)} eV`, 20, y + 4);
                    }
                }
            }
            ctx.setLineDash([]);

            const centerX = width / 2;
            const barrierWidthPixels = Math.max(20, barrierWidth * 25);
            const barrierLeft = centerX - barrierWidthPixels / 2;
            const barrierRight = centerX + barrierWidthPixels / 2;

            drawSemiconductorRegions(ctx, width, height, barrierLeft, barrierRight, voltage);
            drawQuantumBarrier(ctx, barrierLeft, barrierRight, energyZero, barrierHeight, eVtoPixels, voltage);
            drawQuantumBandEdges(ctx, width, height, barrierLeft, barrierRight, energyZero, 
                               eVtoPixels, voltage, barrierHeight, temperature);
            drawFermiLevels(ctx, width, barrierLeft, barrierRight, energyZero, voltage, temperature);

            if (Math.abs(voltage) > 0.05) {
                drawTunnelingTrajectories(ctx, barrierLeft, barrierRight, energyZero, 
                                        barrierHeight, eVtoPixels, voltage);
            }

            drawQuantumLabels(ctx, width, height, voltage, barrierWidth, barrierHeight, temperature);
        }

        function drawSemiconductorRegions(ctx, width, height, barrierLeft, barrierRight, voltage) {
            const pGradient = ctx.createLinearGradient(80, 0, barrierLeft, 0);
            pGradient.addColorStop(0, 'rgba(248, 113, 113, 0.25)');
            pGradient.addColorStop(1, 'rgba(248, 113, 113, 0.15)');
            ctx.fillStyle = pGradient;
            ctx.fillRect(80, height * 0.15, barrierLeft - 80, height * 0.7);

            const nGradient = ctx.createLinearGradient(barrierRight, 0, width - 40, 0);
            nGradient.addColorStop(0, 'rgba(56, 189, 248, 0.15)');
            nGradient.addColorStop(1, 'rgba(56, 189, 248, 0.25)');
            ctx.fillStyle = nGradient;
            ctx.fillRect(barrierRight, height * 0.15, width - 40 - barrierRight, height * 0.7);

            ctx.fillStyle = 'rgba(75, 85, 99, 0.8)';
            ctx.fillRect(60, height * 0.1, 20, height * 0.8);
            ctx.fillRect(width - 80, height * 0.1, 20, height * 0.8);
        }

        function drawQuantumBarrier(ctx, barrierLeft, barrierRight, energyZero, barrierHeight, eVtoPixels, voltage) {
            const barrierTop = energyZero - barrierHeight * eVtoPixels;
            
            const barrierGradient = ctx.createLinearGradient(barrierLeft, barrierTop, barrierRight, energyZero);
            barrierGradient.addColorStop(0, 'rgba(139, 92, 246, 0.4)');
            barrierGradient.addColorStop(0.5, 'rgba(139, 92, 246, 0.6)');
            barrierGradient.addColorStop(1, 'rgba(139, 92, 246, 0.3)');
            
            ctx.fillStyle = barrierGradient;
            ctx.beginPath();
            ctx.moveTo(barrierLeft, energyZero);
            ctx.lineTo(barrierLeft, barrierTop);
            ctx.lineTo(barrierRight, barrierTop);
            ctx.lineTo(barrierRight, energyZero);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = 'rgba(139, 92, 246, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawQuantumBandEdges(ctx, width, height, barrierLeft, barrierRight, energyZero, 
                                    eVtoPixels, voltage, barrierHeight, temperature) {
            const voltageShift = voltage * eVtoPixels * 0.8;
            
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            ctx.moveTo(80, energyZero - 80);
            ctx.lineTo(barrierLeft, energyZero - 80 + voltageShift);
            
            const barrierTop = energyZero - barrierHeight * eVtoPixels;
            ctx.lineTo((barrierLeft + barrierRight) / 2, barrierTop);
            ctx.lineTo(barrierRight, energyZero - 80 + voltageShift);
            
            ctx.lineTo(width - 40, energyZero - 120 + voltageShift);
            ctx.stroke();

            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(80, energyZero + 60);
            ctx.lineTo(barrierLeft, energyZero + 60 + voltageShift);
            ctx.lineTo(barrierRight, energyZero + 60 + voltageShift);
            ctx.lineTo(width - 40, energyZero + 20 + voltageShift);
            ctx.stroke();
        }

        function drawFermiLevels(ctx, width, barrierLeft, barrierRight, energyZero, voltage, temperature) {
            const kT = 8.617e-5 * temperature;
            const thermalWidth = kT * 120;
            
            ctx.strokeStyle = 'rgba(251, 191, 36, 0.9)';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 4]);

            const pFermiY = energyZero + 20;
            ctx.globalAlpha = 0.7;
            for (let offset = -thermalWidth; offset <= thermalWidth; offset += 2) {
                const alpha = Math.exp(-Math.pow(offset / thermalWidth, 2));
                ctx.globalAlpha = 0.3 + 0.4 * alpha;
                ctx.beginPath();
                ctx.moveTo(80, pFermiY + offset);
                ctx.lineTo(barrierLeft, pFermiY + offset + voltage * 60);
                ctx.stroke();
            }

            const nFermiY = energyZero - 70;
            for (let offset = -thermalWidth; offset <= thermalWidth; offset += 2) {
                const alpha = Math.exp(-Math.pow(offset / thermalWidth, 2));
                ctx.globalAlpha = 0.3 + 0.4 * alpha;
                ctx.beginPath();
                ctx.moveTo(barrierRight, nFermiY + voltage * 60);
                ctx.lineTo(width - 40, nFermiY + voltage * 80);
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
            ctx.setLineDash([]);
        }

        function drawTunnelingTrajectories(ctx, barrierLeft, barrierRight, energyZero, 
                                         barrierHeight, eVtoPixels, voltage) {
            const numTrajectories = 12;
            const time = Date.now() * 0.002;
            
            for (let i = 0; i < numTrajectories; i++) {
                const energy = 0.1 + i * 0.15;
                const y = energyZero - energy * eVtoPixels;
                const phase = time + i * 0.3;
                const amplitude = 2 + Math.sin(phase) * 3;
                
                const transmission = Math.exp(-2 * Math.sqrt(2 * 0.511 * 0.067 * 
                    Math.max(0, barrierHeight - energy)) * 2.5 / 0.197);
                const opacity = 0.3 + 0.7 * transmission;
                
                ctx.strokeStyle = `rgba(34, 197, 94, ${opacity})`;
                ctx.lineWidth = 1 + transmission * 2;
                
                ctx.beginPath();
                ctx.moveTo(barrierLeft - 40, y);
                
                const segments = 20;
                for (let s = 0; s <= segments; s++) {
                    const progress = s / segments;
                    const x = barrierLeft + progress * (barrierRight - barrierLeft);
                    const waveY = y + amplitude * Math.sin(phase + progress * 4) * 
                                Math.exp(-progress * 2);
                    
                    if (s === 0) {
                        ctx.moveTo(x, waveY);
                    } else {
                        ctx.lineTo(x, waveY);
                    }
                }
                
                ctx.lineTo(barrierRight + 40, y);
                ctx.stroke();
                
                const arrowSize = 4 + transmission * 6;
                ctx.fillStyle = `rgba(34, 197, 94, ${opacity})`;
                ctx.beginPath();
                ctx.moveTo(barrierRight + 30, y);
                ctx.lineTo(barrierRight + 20, y - arrowSize);
                ctx.lineTo(barrierRight + 20, y + arrowSize);
                ctx.closePath();
                ctx.fill();
            }
        }

        function drawQuantumLabels(ctx, width, height, voltage, barrierWidth, barrierHeight, temperature) {
            ctx.fillStyle = '#1f2937';
            ctx.font = 'bold 16px Inter';
            ctx.fillText('P⁺', 100, height - 30);
            ctx.fillText('N⁺', width - 80, height - 30);
            
            ctx.font = '12px Inter';
            ctx.fillStyle = '#3b82f6';
            ctx.fillText('Ec', width - 60, height * 0.25);
            ctx.fillStyle = '#8b5cf6';
            ctx.fillText('Ev', width - 60, height * 0.75);
            ctx.fillStyle = 'rgba(251, 191, 36, 0.9)';
            ctx.fillText('EF', width - 60, height * 0.55);

            ctx.fillStyle = '#1f2937';
            ctx.font = 'bold 14px Inter';
            ctx.fillText(`V = ${voltage.toFixed(2)} V`, width - 180, 40);
            ctx.fillText(`Width = ${barrierWidth} nm`, width - 180, 60);
            ctx.fillText(`Height = ${barrierHeight} eV`, width - 180, 80);
            ctx.fillText(`T = ${temperature} K`, width - 180, 100);
        }

        function drawQuantumWaveFunction(ctx, width, height, voltage, barrierWidth, barrierHeight, effectiveMass) {
            ctx.fillStyle = '#f8fafc';
            ctx.fillRect(0, 0, width, height);

            const numPoints = 1000;
            const dx = (width - 120) / numPoints;
            const centerX = width / 2;
            const barrierLeft = centerX - barrierWidth * 25 / 2;
            const barrierRight = centerX + barrierWidth * 25 / 2;
            
            const energy = Math.abs(voltage) * 0.8;
            const k = Math.sqrt(2 * 0.511 * effectiveMass * energy) / 0.197;
            const kappa = Math.sqrt(2 * 0.511 * effectiveMass * Math.max(0.01, barrierHeight - energy)) / 0.197;
            
            ctx.strokeStyle = 'rgba(139, 92, 246, 0.6)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(60, height * 0.8);
            ctx.lineTo(barrierLeft, height * 0.8);
            ctx.lineTo(barrierLeft, height * 0.25);
            ctx.lineTo(barrierRight, height * 0.25);
            ctx.lineTo(barrierRight, height * 0.8);
            ctx.lineTo(width - 40, height * 0.8);
            ctx.stroke();

            const amplitude = 60;
            const centerY = height * 0.65;
            const time = Date.now() * 0.003;
            const phaseShift = voltage > 0 ? 0 : Math.PI;
            
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let i = 0; i < numPoints; i++) {
                const x = 60 + i * dx;
                let psi = 0;
                
                if (x < barrierLeft) {
                    const position = (x - barrierLeft) / 25;
                    const incident = Math.sin(k * position + time + phaseShift);
                    const reflected = 0.2 * Math.sin(-k * position + time + phaseShift + Math.PI);
                    psi = amplitude * (incident + reflected);
                } else if (x > barrierRight) {
                    const position = (x - barrierRight) / 25;
                    const transmission = energy > barrierHeight ? 1.0 : Math.exp(-kappa * barrierWidth);
                    psi = amplitude * transmission * Math.sin(k * position + time + phaseShift);
                } else {
                    const position = (x - barrierLeft) / 25;
                    const decay = Math.exp(-kappa * position);
                    psi = amplitude * decay * Math.cos(time * 2 + phaseShift);
                }
                
                const y = centerY + psi;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            ctx.strokeStyle = 'rgba(239, 68, 68, 0.6)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < numPoints; i++) {
                const x = 60 + i * dx;
                let psiImag = 0;
                
                if (x < barrierLeft) {
                    const position = (x - barrierLeft) / 25;
                    psiImag = amplitude * 0.5 * Math.cos(k * position + time + phaseShift);
                } else if (x > barrierRight) {
                    const position = (x - barrierRight) / 25;
                    const transmission = energy > barrierHeight ? 1.0 : Math.exp(-kappa * barrierWidth);
                    psiImag = amplitude * transmission * 0.5 * Math.cos(k * position + time + phaseShift);
                } else {
                    const position = (x - barrierLeft) / 25;
                    const decay = Math.exp(-kappa * position);
                    psiImag = amplitude * decay * 0.3 * Math.sin(time * 2 + phaseShift);
                }
                
                const y = centerY + 80 + psiImag;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            ctx.fillStyle = '#1f2937';
            ctx.font = '14px Inter';
            ctx.fillText('Re[ψ(x)]', 20, centerY - 60);
            ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
            ctx.fillText('Im[ψ(x)]', 20, centerY + 120);
            
            ctx.fillStyle = '#1f2937';
            ctx.font = '12px Inter';
            ctx.fillText(`k = ${k.toFixed(2)} nm⁻¹`, width - 150, 40);
            ctx.fillText(`κ = ${kappa.toFixed(2)} nm⁻¹`, width - 150, 60);
            ctx.fillText(`E = ${energy.toFixed(2)} eV`, width - 150, 80);
        }

        function drawQuantumProbabilityDensity(ctx, width, height, voltage, barrierWidth, barrierHeight, effectiveMass) {
            ctx.fillStyle = '#f8fafc';
            ctx.fillRect(0, 0, width, height);

            const gridSize = 3;
            const time = Date.now() * 0.001;
            const centerX = width / 2;
            const barrierLeft = centerX - barrierWidth * 25 / 2;
            const barrierRight = centerX + barrierWidth * 25 / 2;
            
            for (let x = 60; x < width - 40; x += gridSize) {
                for (let y = height * 0.2; y < height * 0.8; y += gridSize) {
                    let probability = 0;
                    const energy = Math.abs(voltage) * 0.8;
                    
                    if (x < barrierLeft) {
                        const k = Math.sqrt(2 * 0.511 * effectiveMass * energy) / 0.197;
                        const position = (x - barrierLeft) / 25;
                        const standingWave = Math.pow(Math.sin(k * position + time) + 
                                           0.3 * Math.sin(-k * position + time), 2);
                        probability = 0.7 + 0.3 * standingWave;
                    } else if (x > barrierRight) {
                        const kappa = Math.sqrt(2 * 0.511 * effectiveMass * 
                            Math.max(0.01, barrierHeight - energy)) / 0.197;
                        const transmission = energy > barrierHeight ? 1.0 : Math.exp(-2 * kappa * barrierWidth);
                        const k = Math.sqrt(2 * 0.511 * effectiveMass * energy) / 0.197;
                        const position = (x - barrierRight) / 25;
                        const wave = Math.pow(Math.sin(k * position + time), 2);
                        probability = transmission * (0.7 + 0.3 * wave);
                    } else {
                        const kappa = Math.sqrt(2 * 0.511 * effectiveMass * 
                            Math.max(0.01, barrierHeight - energy)) / 0.197;
                        const position = (x - barrierLeft) / 25;
                        probability = Math.exp(-2 * kappa * position) * 0.8;
                    }
                    
                    const verticalFactor = Math.exp(-Math.pow((y - height/2) / (height/6), 2));
                    probability *= verticalFactor;
                    
                    const alpha = Math.min(1, probability * 1.5);
                    const hue = 60 + (1 - probability) * 180;
                    const saturation = 50 + probability * 40;
                    const lightness = 40 + probability * 40;
                    
                    ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;
                    ctx.fillRect(x, y, gridSize, gridSize);
                }
            }

            const numArrows = 15;
            for (let i = 0; i < numArrows; i++) {
                const y = height * 0.3 + i * (height * 0.4 / numArrows);
                const energy = Math.abs(voltage) * 0.8;
                const transmission = energy > barrierHeight ? 1.0 : 
                    Math.exp(-2 * Math.sqrt(2 * 0.511 * effectiveMass * 
                    Math.max(0.01, barrierHeight - energy)) * barrierWidth / 0.197);
                
                const incidentX = barrierLeft - 60;
                const arrowLength = 25;
                const offset = Math.sin(time + i * 0.3) * 8;
                
                ctx.strokeStyle = 'rgba(34, 197, 94, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(incidentX + offset, y);
                ctx.lineTo(incidentX + offset + arrowLength, y);
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(34, 197, 94, 0.8)';
                ctx.beginPath();
                ctx.moveTo(incidentX + offset + arrowLength, y);
                ctx.lineTo(incidentX + offset + arrowLength - 6, y - 4);
                ctx.lineTo(incidentX + offset + arrowLength - 6, y + 4);
                ctx.closePath();
                ctx.fill();
                
                const transmittedX = barrierRight + 30;
                ctx.strokeStyle = `rgba(34, 197, 94, ${0.8 * transmission})`;
                ctx.lineWidth = 2 * transmission;
                ctx.beginPath();
                ctx.moveTo(transmittedX + offset, y);
                ctx.lineTo(transmittedX + offset + arrowLength * transmission, y);
                ctx.stroke();
                
                if (transmission > 0.1) {
                    ctx.fillStyle = `rgba(34, 197, 94, ${0.8 * transmission})`;
                    ctx.beginPath();
                    const endX = transmittedX + offset + arrowLength * transmission;
                    ctx.moveTo(endX, y);
                    ctx.lineTo(endX - 6, y - 4);
                    ctx.lineTo(endX - 6, y + 4);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            ctx.strokeStyle = 'rgba(139, 92, 246, 0.8)';
            ctx.lineWidth = 2;
            ctx.strokeRect(barrierLeft, height * 0.25, barrierRight - barrierLeft, height * 0.5);
            
            ctx.fillStyle = '#1f2937';
            ctx.font = '12px Inter';
            ctx.fillText('High Probability', 20, 40);
            ctx.fillStyle = 'rgba(120, 255, 120, 0.8)';
            ctx.fillRect(130, 32, 20, 12);
            
            ctx.fillStyle = '#1f2937';
            ctx.fillText('Low Probability', 20, 60);
            ctx.fillStyle = 'rgba(120, 120, 255, 0.8)';
            ctx.fillRect(125, 52, 20, 12);
            
            const transmission = Math.exp(-2 * Math.sqrt(2 * 0.511 * effectiveMass * 
                Math.max(0.01, barrierHeight - Math.abs(voltage) * 0.8)) * barrierWidth / 0.197);
            ctx.fillStyle = '#1f2937';
            ctx.font = '14px Inter';
            ctx.fillText(`Transmission: ${(transmission * 100).toFixed(2)}%`, width - 200, height - 40);
        }

        function startTunnelingAnimation() {
            if (tunnelingAnimationId) {
                cancelAnimationFrame(tunnelingAnimationId);
            }
            
            function animate() {
                updateTunnelingVisualization();
                tunnelingAnimationId = requestAnimationFrame(animate);
            }
            
            animate();
        }

        function calculateTransmission() {
            if (typeof Plotly === 'undefined') return;
            
            const barrierWidth = parseFloat(document.getElementById('barrierWidth').value);
            const barrierHeight = parseFloat(document.getElementById('barrierHeight').value);
            const effectiveMass = parseFloat(document.getElementById('effectiveMass').value);
            
            const energies = [];
            const transmissions = [];
            const reflections = [];
            
            for (let E = 0.001; E <= 3.0; E += 0.005) {
                energies.push(E);
                
                let T, R;
                if (E >= barrierHeight) {
                    const k1 = Math.sqrt(2 * 0.511 * effectiveMass * E) / 0.197;
                    const k2 = Math.sqrt(2 * 0.511 * effectiveMass * (E - barrierHeight)) / 0.197;
                    const r = (k1 - k2) / (k1 + k2);
                    T = (1 - r * r) * Math.exp(-2 * Math.abs(k2) * barrierWidth);
                    T = Math.min(1.0, T);
                } else {
                    const kappa = Math.sqrt(2 * 0.511 * effectiveMass * (barrierHeight - E)) / 0.197;
                    T = 1 / (1 + Math.pow(Math.sinh(kappa * barrierWidth), 2) / 4);
                }
                
                R = 1 - T;
                transmissions.push(T);
                reflections.push(R);
            }
            
            const transmissionTrace = {
                x: energies,
                y: transmissions,
                type: 'scatter',
                mode: 'lines',
                name: 'Transmission T(E)',
                line: { 
                    color: '#10b981', 
                    width: 3,
                    shape: 'spline'
                },
                fill: 'tozeroy',
                fillcolor: 'rgba(16, 185, 129, 0.2)'
            };
            
            const reflectionTrace = {
                x: energies,
                y: reflections,
                type: 'scatter',
                mode: 'lines',
                name: 'Reflection R(E)',
                line: { 
                    color: '#ef4444', 
                    width: 2,
                    dash: 'dot'
                }
            };
            
            const barrierTrace = {
                x: [barrierHeight, barrierHeight],
                y: [0, 1],
                type: 'scatter',
                mode: 'lines',
                name: `Barrier (${barrierHeight} eV)`,
                line: { 
                    color: '#8b5cf6', 
                    width: 2, 
                    dash: 'dash' 
                }
            };
            
            const layout = {
                title: { text: 'Transmission Probability vs Energy', font: { size: 16 } },
                margin: { t: 50, r: 50, b: 80, l: 80 },
                xaxis: { 
                    title: { 
                        text: 'Energy (eV)',
                        font: { size: 16, color: '#374151', family: 'Inter' },
                        standoff: 20
                    }, 
                    gridcolor: 'rgba(107,114,128,0.2)',
                    showgrid: true,
                    zeroline: false,
                    tickfont: { size: 14, color: '#374151', family: 'Inter' },
                    showline: true,
                    linecolor: '#374151',
                    linewidth: 1
                },
                yaxis: { 
                    title: { 
                        text: 'Transmission T(E)',
                        font: { size: 16, color: '#374151', family: 'Inter' },
                        standoff: 20
                    }, 
                    gridcolor: 'rgba(107,114,128,0.2)',
                    showgrid: true,
                    zeroline: false,
                    range: [0, 1],
                    tickfont: { size: 14, color: '#374151', family: 'Inter' },
                    showline: true,
                    linecolor: '#374151',
                    linewidth: 1
                },
                font: { 
                    family: 'Inter, Arial, sans-serif', 
                    size: 14, 
                    color: '#374151' 
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: '#ffffff',
                showlegend: true,
                legend: {
                    x: 0.7,
                    y: 0.95,
                    bgcolor: 'rgba(255, 255, 255, 0.8)',
                    bordercolor: 'rgba(0, 0, 0, 0.1)',
                    borderwidth: 1
                }
            };
            
            Plotly.react('transmissionChart', [transmissionTrace, reflectionTrace, barrierTrace], layout);
        }

        // Carrier dynamics and transport comparison
        function runTransportComparison() {
            if (typeof Plotly === 'undefined') return;
            
            const amplitude = parseFloat(document.getElementById('pulseAmplitude').value);
            const riseTime = parseFloat(document.getElementById('riseTime').value);
            const deviceLength = parseFloat(document.getElementById('deviceLength').value);
            const dopingLevel = Math.pow(10, parseFloat(document.getElementById('dopingLevel').value));
            
            const timePoints = [];
            const driftCurrent = [];
            const tunnelCurrent = [];
            const ballisticCurrent = [];
            
            for (let t = 0; t <= 500; t += 0.2) {
                timePoints.push(t);
                
                const voltage = amplitude * (1 - Math.exp(-t / riseTime));
                
                const mobility = 1400e-4 / (1 + Math.pow(dopingLevel / 1e23, 0.7));
                const tauDrift = deviceLength * 1e-9 / (mobility * voltage * 1e5) * 1e12;
                const driftI = amplitude * 15 * (1 - Math.exp(-t / Math.max(5, tauDrift))) * 
                              Math.max(0, voltage / amplitude);
                
                const tauTunnel = 0.5 + deviceLength / 200;
                const tunnelI = amplitude * 25 * (1 - Math.exp(-t / tauTunnel)) * 
                               Math.max(0, voltage / amplitude);
                
                const satVelocity = 1e7;
                const tauBallistic = deviceLength * 1e-9 / satVelocity * 1e12;
                const ballisticI = amplitude * 20 * (1 - Math.exp(-t / Math.max(2, tauBallistic))) * 
                                  Math.max(0, voltage / amplitude);
                
                driftCurrent.push(driftI);
                tunnelCurrent.push(tunnelI);
                ballisticCurrent.push(ballisticI);
            }
            
            const driftTrace = {
                x: timePoints,
                y: driftCurrent,
                type: 'scatter',
                mode: 'lines',
                name: 'Drift/Diffusion',
                line: { color: '#ef4444', width: 3 }
            };
            
            const tunnelTrace = {
                x: timePoints,
                y: tunnelCurrent,
                type: 'scatter',
                mode: 'lines',
                name: 'Quantum Tunneling',
                line: { color: '#10b981', width: 3 }
            };
            
            const ballisticTrace = {
                x: timePoints,
                y: ballisticCurrent,
                type: 'scatter',
                mode: 'lines',
                name: 'Ballistic Transport',
                line: { color: '#3b82f6', width: 3 }
            };
            
            const layout = {
                title: { text: 'Current Response Comparison', font: { size: 16 } },
                margin: { t: 50, r: 50, b: 80, l: 80 },
                xaxis: { 
                    title: { 
                        text: 'Time (ps)',
                        font: { size: 16, color: '#374151', family: 'Inter' },
                        standoff: 20
                    }, 
                    gridcolor: 'rgba(107,114,128,0.2)',
                    showgrid: true,
                    zeroline: false,
                    tickfont: { size: 14, color: '#374151', family: 'Inter' },
                    showline: true,
                    linecolor: '#374151',
                    linewidth: 1
                },
                yaxis: { 
                    title: { 
                        text: 'Current (mA)',
                        font: { size: 16, color: '#374151', family: 'Inter' },
                        standoff: 20
                    }, 
                    gridcolor: 'rgba(107,114,128,0.2)',
                    showgrid: true,
                    zeroline: false,
                    tickfont: { size: 14, color: '#374151', family: 'Inter' },
                    showline: true,
                    linecolor: '#374151',
                    linewidth: 1
                },
                font: { 
                    family: 'Inter, Arial, sans-serif', 
                    size: 14, 
                    color: '#374151' 
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: '#ffffff',
                showlegend: true,
                legend: {
                    x: 0.7,
                    y: 0.95,
                    bgcolor: 'rgba(255, 255, 255, 0.8)',
                    bordercolor: 'rgba(0, 0, 0, 0.1)',
                    borderwidth: 1
                }
            };
            
            Plotly.react('responseChart', [driftTrace, tunnelTrace, ballisticTrace], layout);
            
            updateTransportCalculations();
            startCarrierDynamicsVisualization();
        }

        function startCarrierDynamicsVisualization() {
            if (carrierAnimationId) {
                cancelAnimationFrame(carrierAnimationId);
            }
            
            initializeCarrierCanvas();
            initializeCarrierParticles();
            
            function animate() {
                updateCarrierVisualization();
                carrierAnimationId = requestAnimationFrame(animate);
            }
            
            animate();
        }

        function initializeCarrierCanvas() {
            const canvas = document.getElementById('carrierCanvas');
            if (!canvas) return;
            
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            const width = Math.max(containerWidth - 20, 400);
            const height = Math.max(containerHeight - 20, 300);
            
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.style.display = 'block';
            canvas.style.margin = '10px auto';
        }

        function initializeCarrierParticles() {
            const canvas = document.getElementById('carrierCanvas');
            if (!canvas) return;
            
            const width = canvas.width;
            const height = canvas.height;
            particles = [];
            
            for (let i = 0; i < 20; i++) {
                particles.push({
                    type: 'electron-tunnel',
                    x: width * 0.08 + Math.random() * width * 0.12,
                    y: height * 0.2 + Math.random() * height * 0.25,
                    vx: 0,
                    vy: 0,
                    size: 3 + Math.random() * 2,
                    opacity: 0.7 + Math.random() * 0.3,
                    trail: [],
                    energy: 0.3 + Math.random() * 0.4,
                    phase: Math.random() * Math.PI * 2,
                    generation: 1
                });
            }
            
            for (let i = 0; i < 18; i++) {
                particles.push({
                    type: 'electron-drift',
                    x: width * 0.08 + Math.random() * width * 0.12,
                    y: height * 0.5 + Math.random() * height * 0.25,
                    vx: 0,
                    vy: 0,
                    size: 3 + Math.random() * 2,
                    opacity: 0.7 + Math.random() * 0.3,
                    trail: [],
                    energy: 0.2 + Math.random() * 0.3,
                    phase: Math.random() * Math.PI * 2,
                    scatterTime: 0
                });
            }
            
            for (let i = 0; i < 15; i++) {
                particles.push({
                    type: 'electron-ballistic',
                    x: width * 0.08 + Math.random() * width * 0.12,
                    y: height * 0.75 + Math.random() * height * 0.2,
                    vx: 0,
                    vy: 0,
                    size: 3 + Math.random() * 2,
                    opacity: 0.7 + Math.random() * 0.3,
                    trail: [],
                    energy: 0.4 + Math.random() * 0.3,
                    phase: Math.random() * Math.PI * 2
                });
            }
            
            for (let i = 0; i < 12; i++) {
                particles.push({
                    type: 'hole',
                    x: width * 0.8 + Math.random() * width * 0.12,
                    y: height * 0.3 + Math.random() * height * 0.4,
                    vx: 0,
                    vy: 0,
                    size: 4 + Math.random() * 2,
                    opacity: 0.6 + Math.random() * 0.3,
                    trail: [],
                    energy: 0.2 + Math.random() * 0.2,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }

        function updateCarrierVisualization() {
            const canvas = document.getElementById('carrierCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            const bgGradient = ctx.createLinearGradient(0, 0, width, height);
            bgGradient.addColorStop(0, '#f8fafc');
            bgGradient.addColorStop(0.5, '#f1f5f9');
            bgGradient.addColorStop(1, '#e2e8f0');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, width, height);
            
            const amplitude = parseFloat(document.getElementById('pulseAmplitude').value);
            const deviceLength = parseFloat(document.getElementById('deviceLength').value);
            const time = Date.now() * 0.001;
            
            drawEnhancedDeviceStructure(ctx, width, height, amplitude);
            updateEnhancedParticlePhysics(time, amplitude, deviceLength, width, height);
            drawEnhancedParticles(ctx, width, height);
            drawTransportMechanismLabels(ctx, width, height);
        }

        function drawEnhancedDeviceStructure(ctx, width, height, amplitude) {
            ctx.fillStyle = 'rgba(75, 85, 99, 0.9)';
            ctx.fillRect(width * 0.02, height * 0.1, width * 0.08, height * 0.8);
            ctx.fillRect(width * 0.9, height * 0.1, width * 0.08, height * 0.8);
            
            const pGradient = ctx.createLinearGradient(width * 0.1, 0, width * 0.3, 0);
            pGradient.addColorStop(0, 'rgba(248, 113, 113, 0.3)');
            pGradient.addColorStop(1, 'rgba(248, 113, 113, 0.15)');
            ctx.fillStyle = pGradient;
            ctx.fillRect(width * 0.1, height * 0.1, width * 0.2, height * 0.8);
            
            const activeGradient = ctx.createLinearGradient(width * 0.3, 0, width * 0.7, 0);
            activeGradient.addColorStop(0, 'rgba(139, 92, 246, 0.1)');
            activeGradient.addColorStop(0.5, 'rgba(139, 92, 246, 0.4)');
            activeGradient.addColorStop(1, 'rgba(139, 92, 246, 0.1)');
            ctx.fillStyle = activeGradient;
            ctx.fillRect(width * 0.3, height * 0.1, width * 0.4, height * 0.8);
            
            const nGradient = ctx.createLinearGradient(width * 0.7, 0, width * 0.9, 0);
            nGradient.addColorStop(0, 'rgba(56, 189, 248, 0.15)');
            nGradient.addColorStop(1, 'rgba(56, 189, 248, 0.3)');
            ctx.fillStyle = nGradient;
            ctx.fillRect(width * 0.7, height * 0.1, width * 0.2, height * 0.8);
            
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.5)';
            ctx.lineWidth = 1;
            ctx.setLineDash([8, 4]);
            
            ctx.beginPath();
            ctx.moveTo(width * 0.1, height * 0.45);
            ctx.lineTo(width * 0.9, height * 0.45);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(width * 0.1, height * 0.7);
            ctx.lineTo(width * 0.9, height * 0.7);
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            drawDynamicElectricField(ctx, width, height, amplitude);
            
            ctx.fillStyle = '#1f2937';
            ctx.font = `bold ${Math.max(12, width * 0.018)}px Inter`;
            ctx.fillText('P⁺', width * 0.18, height * 0.96);
            ctx.fillText('Active Region', width * 0.45, height * 0.96);
            ctx.fillText('N⁺', width * 0.78, height * 0.96);
        }

        function drawDynamicElectricField(ctx, width, height, amplitude) {
            const fieldStrength = amplitude * 2;
            const numLines = 8;
            const time = Date.now() * 0.002;
            
            for (let i = 0; i < numLines; i++) {
                const y = height * 0.15 + i * (height * 0.7) / numLines;
                const startX = width * 0.3;
                const endX = width * 0.7;
                
                const fieldProfile = 1 + 0.5 * Math.sin((i / numLines) * Math.PI);
                const localField = fieldStrength * fieldProfile;
                const alpha = 0.2 + localField * 0.3;
                
                const phase = time + i * 0.2;
                const wiggle = Math.sin(phase) * 3;
                
                ctx.strokeStyle = `rgba(99, 102, 241, ${alpha})`;
                ctx.lineWidth = 1 + localField;
                
                ctx.beginPath();
                ctx.moveTo(startX, y + wiggle);
                ctx.quadraticCurveTo(
                    (startX + endX) / 2, y + wiggle + Math.sin(phase * 2) * 5,
                    endX, y + wiggle
                );
                ctx.stroke();
                
                const numArrows = 3;
                for (let j = 0; j < numArrows; j++) {
                    const arrowX = startX + (j + 1) * (endX - startX) / (numArrows + 1);
                    const arrowY = y + wiggle + Math.sin(phase * 2 + j) * 2;
                    
                    ctx.fillStyle = `rgba(99, 102, 241, ${alpha})`;
                    ctx.beginPath();
                    ctx.moveTo(arrowX, arrowY);
                    ctx.lineTo(arrowX - 8, arrowY - 4);
                    ctx.lineTo(arrowX - 8, arrowY + 4);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            ctx.fillStyle = '#3b82f6';
            ctx.font = `${Math.max(11, width * 0.016)}px Inter`;
            ctx.fillText(`E-field: ${(fieldStrength * 100).toFixed(0)} kV/cm`, width * 0.7, height * 0.05);
        }

        function updateEnhancedParticlePhysics(time, amplitude, deviceLength, width, height) {
            const fieldStrength = amplitude;
            const deviceRegionStart = width * 0.3;
            const deviceRegionEnd = width * 0.7;
            
            particles.forEach((particle, index) => {
                particle.vx = 0;
                particle.vy = 0;
                
                switch (particle.type) {
                    case 'electron-tunnel':
                        updateTunnelingElectron(particle, time, fieldStrength, deviceRegionStart, 
                                              deviceRegionEnd, width, height, index);
                        break;
                    case 'electron-drift':
                        updateDriftElectron(particle, time, fieldStrength, deviceRegionStart, 
                                          deviceRegionEnd, width, height, index);
                        break;
                    case 'electron-ballistic':
                        updateBallisticElectron(particle, time, fieldStrength, deviceRegionStart, 
                                              deviceRegionEnd, width, height, index);
                        break;
                    case 'hole':
                        updateHole(particle, time, fieldStrength, deviceRegionStart, 
                                 deviceRegionEnd, width, height, index);
                        break;
                }
                
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                particle.trail.push({ 
                    x: particle.x, 
                    y: particle.y, 
                    time: time,
                    intensity: particle.energy 
                });
                if (particle.trail.length > 20) {
                    particle.trail.shift();
                }
                
                handleParticleBoundaries(particle, width, height);
                
                particle.y = Math.max(height * 0.12, Math.min(particle.y, height * 0.88));
            });
        }

        function updateTunnelingElectron(particle, time, fieldStrength, regionStart, regionEnd, width, height, index) {
            const baseSpeed = (2 + fieldStrength * 4) * width * 0.0015;
            const phase = time + particle.phase + index * 0.1;
            
            if (particle.x < regionStart) {
                particle.vx = baseSpeed * 0.8;
                particle.vy = Math.sin(phase) * height * 0.0008;
            } else if (particle.x >= regionStart && particle.x <= regionEnd) {
                particle.vx = baseSpeed * (3 + Math.sin(phase * 4));
                particle.vy = Math.sin(phase * 6) * height * 0.002;
                particle.opacity = 0.3 + 0.5 * Math.abs(Math.sin(phase * 3));
                
                if (Math.random() < 0.02) {
                    particle.energy += 0.1;
                    particle.size += 0.5;
                }
            } else {
                particle.vx = baseSpeed * 1.2;
                particle.vy = Math.sin(phase * 0.5) * height * 0.0005;
                particle.opacity = Math.min(1, particle.opacity + 0.02);
            }
        }

        function updateDriftElectron(particle, time, fieldStrength, regionStart, regionEnd, width, height, index) {
            const baseSpeed = (1 + fieldStrength * 2) * width * 0.001;
            const phase = time * 0.7 + particle.phase + index * 0.15;
            
            if (particle.x < regionStart) {
                particle.vx = baseSpeed * 0.9;
                particle.vy = Math.sin(phase) * height * 0.001;
            } else if (particle.x >= regionStart && particle.x <= regionEnd) {
                particle.vx = baseSpeed * (1.5 + fieldStrength);
                particle.vy = Math.sin(phase) * height * 0.003;
                
                particle.scatterTime += 0.02;
                if (particle.scatterTime > 1 && Math.random() < 0.08) {
                    particle.vx *= 0.3;
                    particle.vy += (Math.random() - 0.5) * height * 0.008;
                    particle.scatterTime = 0;
                    particle.energy *= 0.9;
                }
            } else {
                particle.vx = baseSpeed * 1.3;
                particle.vy = Math.sin(phase * 0.3) * height * 0.0008;
            }
        }

        function updateBallisticElectron(particle, time, fieldStrength, regionStart, regionEnd, width, height, index) {
            const baseSpeed = (1.8 + fieldStrength * 3) * width * 0.0012;
            const phase = time * 1.2 + particle.phase + index * 0.08;
            
            if (particle.x < regionStart) {
                particle.vx = baseSpeed * 0.95;
                particle.vy = Math.sin(phase) * height * 0.0012;
            } else if (particle.x >= regionStart && particle.x <= regionEnd) {
                const progress = (particle.x - regionStart) / (regionEnd - regionStart);
                const acceleration = 1 + progress * fieldStrength;
                particle.vx = baseSpeed * acceleration;
                particle.vy = Math.sin(phase * 2) * height * 0.0015 * (1 - progress * 0.5);
                
                particle.energy = Math.min(1, particle.energy + 0.002);
            } else {
                particle.vx = baseSpeed * (2 + fieldStrength * 0.5);
                particle.vy = Math.sin(phase * 0.8) * height * 0.001;
            }
        }

        function updateHole(particle, time, fieldStrength, regionStart, regionEnd, width, height, index) {
            const baseSpeed = (0.8 + fieldStrength * 1.5) * width * 0.0008;
            const phase = time * 0.5 + particle.phase + index * 0.2;
            
            particle.vx = -baseSpeed;
            particle.vy = Math.sin(phase) * height * 0.0015;
            
            if (particle.x >= regionStart && particle.x <= regionEnd) {
                particle.vx *= (1 + fieldStrength * 0.8);
                particle.vy *= 1.2;
            }
        }

        function handleParticleBoundaries(particle, width, height) {
            if (particle.type.includes('electron')) {
                if (particle.x > width * 0.95) {
                    particle.x = width * 0.08 + Math.random() * width * 0.12;
                    particle.y = getInitialYPosition(particle.type, height);
                    particle.trail = [];
                    particle.energy = 0.2 + Math.random() * 0.3;
                    particle.size = 3 + Math.random() * 2;
                    particle.opacity = 0.7 + Math.random() * 0.3;
                    if (particle.type === 'electron-drift') {
                        particle.scatterTime = 0;
                    }
                }
            } else if (particle.type === 'hole') {
                if (particle.x < width * 0.05) {
                    particle.x = width * 0.8 + Math.random() * width * 0.12;
                    particle.y = height * 0.3 + Math.random() * height * 0.4;
                    particle.trail = [];
                    particle.energy = 0.2 + Math.random() * 0.2;
                    particle.size = 4 + Math.random() * 2;
                    particle.opacity = 0.6 + Math.random() * 0.3;
                }
            }
        }

        function getInitialYPosition(type, height) {
            switch (type) {
                case 'electron-tunnel':
                    return height * 0.2 + Math.random() * height * 0.25;
                case 'electron-drift':
                    return height * 0.5 + Math.random() * height * 0.25;
                case 'electron-ballistic':
                    return height * 0.75 + Math.random() * height * 0.2;
                default:
                    return height * 0.5;
            }
        }

        function drawEnhancedParticles(ctx, width, height) {
            particles.forEach(particle => {
                drawParticleTrail(ctx, particle);
                drawParticleWithEffects(ctx, particle);
                drawParticleSymbol(ctx, particle);
            });
        }

        function drawParticleTrail(ctx, particle) {
            if (particle.trail.length < 2) return;
            
            ctx.strokeStyle = getTrailColor(particle.type);
            ctx.lineWidth = 1.5;
            
            for (let i = 1; i < particle.trail.length; i++) {
                const alpha = (i / particle.trail.length) * 0.6;
                ctx.globalAlpha = alpha;
                
                ctx.beginPath();
                ctx.moveTo(particle.trail[i-1].x, particle.trail[i-1].y);
                ctx.lineTo(particle.trail[i].x, particle.trail[i].y);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }

        function getTrailColor(type) {
            switch (type) {
                case 'electron-tunnel': return 'rgba(34, 197, 94, 0.8)';
                case 'electron-drift': return 'rgba(239, 68, 68, 0.8)';
                case 'electron-ballistic': return 'rgba(59, 130, 246, 0.8)';
                case 'hole': return 'rgba(168, 85, 247, 0.8)';
                default: return 'rgba(107, 114, 128, 0.8)';
            }
        }

        function drawParticleWithEffects(ctx, particle) {
            const glowRadius = particle.size + particle.energy * 12;
            
            const gradient = ctx.createRadialGradient(
                particle.x, particle.y, 0,
                particle.x, particle.y, glowRadius
            );
            
            const color = getParticleColor(particle.type);
            gradient.addColorStop(0, color.replace('1)', `${particle.opacity})`));
            gradient.addColorStop(1, color.replace('1)', '0)'));
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, glowRadius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = color.replace('0.8', '1');
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            ctx.fill();
        }

        function getParticleColor(type) {
            switch (type) {
                case 'electron-tunnel': return 'rgba(34, 197, 94, 0.8)';
                case 'electron-drift': return 'rgba(239, 68, 68, 0.8)';
                case 'electron-ballistic': return 'rgba(59, 130, 246, 0.8)';
                case 'hole': return 'rgba(168, 85, 247, 0.8)';
                default: return 'rgba(107, 114, 128, 0.8)';
            }
        }

        function drawParticleSymbol(ctx, particle) {
            ctx.fillStyle = 'white';
            ctx.font = `bold ${Math.max(6, particle.size)}px Inter`;
            ctx.textAlign = 'center';
            ctx.fillText(
                particle.type === 'hole' ? '+' : '−',
                particle.x, particle.y + 2
            );
            
            if (particle.energy > 0.6) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = `${Math.max(6, particle.size * 0.7)}px Inter`;
                ctx.fillText('⚡', particle.x + particle.size + 2, particle.y - particle.size);
            }
        }

        function drawTransportMechanismLabels(ctx, width, height) {
            const fontSize = Math.max(11, width * 0.016);
            ctx.font = `bold ${fontSize}px Inter`;
            
            ctx.fillStyle = '#22c55e';
            ctx.fillText('Quantum Tunneling (Ultrafast)', width * 0.25, height * 0.35);
            
            ctx.fillStyle = '#ef4444';
            ctx.fillText('Drift/Diffusion (Classical)', width * 0.25, height * 0.6);
            
            ctx.fillStyle = '#3b82f6';
            ctx.fillText('Ballistic Transport (High-Field)', width * 0.25, height * 0.85);
            
            const legendX = width * 0.75;
            const legendY = height * 0.15;
            const circleRadius = Math.max(4, width * 0.008);
            const lineSpacing = height * 0.045;
            
            const mechanisms = [
                { color: 'rgba(34, 197, 94, 0.9)', label: 'Tunneling e⁻', symbol: '−' },
                { color: 'rgba(239, 68, 68, 0.9)', label: 'Drift e⁻', symbol: '−' },
                { color: 'rgba(59, 130, 246, 0.9)', label: 'Ballistic e⁻', symbol: '−' },
                { color: 'rgba(168, 85, 247, 0.9)', label: 'Holes h⁺', symbol: '+' }
            ];
            
            mechanisms.forEach((mech, i) => {
                const y = legendY + i * lineSpacing;
                
                ctx.fillStyle = mech.color;
                ctx.beginPath();
                ctx.arc(legendX, y, circleRadius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = `bold ${Math.max(8, circleRadius)}px Inter`;
                ctx.textAlign = 'center';
                ctx.fillText(mech.symbol, legendX, y + 3);
                
                ctx.fillStyle = '#1f2937';
                ctx.font = `${Math.max(9, width * 0.013)}px Inter`;
                ctx.textAlign = 'left';
                ctx.fillText(mech.label, legendX + width * 0.025, y + 4);
            });
        }

        // IMPATT Dynamics Implementation
        function startImpattOscillation() {
            if (isImpattRunning) return;
            isImpattRunning = true;
            
            const bias = parseFloat(document.getElementById('impattBias').value);
            const freq = parseFloat(document.getElementById('impattFreq').value);
            const driftLength = parseFloat(document.getElementById('driftLength').value);
            
            initializeImpattCanvas();
            initializeAvalancheParticles();
            
            let timeIndex = 0;
            const timeData = [];
            const currentData = [];
            const voltageData = [];
            
            function updateImpatt() {
                if (!isImpattRunning) return;
                
                const t = timeIndex * 0.005;
                const omega = 2 * Math.PI * freq * 1e9;
                
                const envelope = 1 - Math.exp(-t * 2);
                const oscillation = envelope * Math.sin(omega * t * 1e-9);
                const current = 5 + bias * 0.2 + 10 * oscillation;
                const voltage = bias + 5 * oscillation;
                
                timeData.push(t);
                currentData.push(Math.max(0, current));
                voltageData.push(voltage);
                
                if (timeData.length > 2000) {
                    timeData.shift();
                    currentData.shift();
                    voltageData.shift();
                }
                
                updateAvalancheMultiplication(t, bias, current, voltage);
                
                if (timeIndex % 20 === 0 && typeof Plotly !== 'undefined') {
                    updateImpattCharts(timeData, currentData, voltageData, freq);
                }
                
                updateImpattStatus(bias, current, voltage, freq);
                
                timeIndex++;
                if (isImpattRunning) {
                    setTimeout(updateImpatt, 25);
                }
            }
            
            updateImpatt();
        }

        function initializeImpattCanvas() {
            const canvas = document.getElementById('impattCanvas');
            if (!canvas) return;
            
            const container = canvas.parentElement;
            const width = Math.max(container.clientWidth - 20, 400);
            const height = Math.max(container.clientHeight - 20, 300);
            
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.style.display = 'block';
            canvas.style.margin = '10px auto';
        }

        function initializeAvalancheParticles() {
            const canvas = document.getElementById('impattCanvas');
            if (!canvas) return;
            
            const width = canvas.width;
            const height = canvas.height;
            
            avalancheParticles = [];
            impactEvents = [];
            
            for (let i = 0; i < 12; i++) {
                avalancheParticles.push({
                    type: 'electron',
                    x: width * 0.25 + Math.random() * width * 0.1,
                    y: height * 0.3 + Math.random() * height * 0.4,
                    vx: 0,
                    vy: 0,
                    energy: 0.2 + Math.random() * 0.3,
                    age: 0,
                    generation: 1,
                    size: 3 + Math.random(),
                    opacity: 0.8,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }

        function updateAvalancheMultiplication(time, bias, current, voltage) {
            const canvas = document.getElementById('impattCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            drawImpattStructure(ctx, width, height, bias, voltage);
            updateAvalanchePhysics(time, bias, current, width, height);
            drawAvalancheElements(ctx, width, height, time);
            drawImpattInformation(ctx, width, height, bias, current);
        }

        function drawImpattStructure(ctx, width, height, bias, voltage) {
            const bgGradient = ctx.createLinearGradient(0, 0, width, height);
            bgGradient.addColorStop(0, '#f8fafc');
            bgGradient.addColorStop(0.5, '#f1f5f9');
            bgGradient.addColorStop(1, '#e2e8f0');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, width, height);
            
            ctx.fillStyle = 'rgba(239, 68, 68, 0.6)';
            ctx.fillRect(width * 0.05, height * 0.1, width * 0.15, height * 0.8);
            
            const driftGradient = ctx.createLinearGradient(width * 0.2, 0, width * 0.8, 0);
            driftGradient.addColorStop(0, 'rgba(139, 92, 246, 0.2)');
            driftGradient.addColorStop(0.4, 'rgba(255, 193, 7, 0.4)');
            driftGradient.addColorStop(0.6, 'rgba(255, 193, 7, 0.4)');
            driftGradient.addColorStop(1, 'rgba(139, 92, 246, 0.2)');
            ctx.fillStyle = driftGradient;
            ctx.fillRect(width * 0.2, height * 0.1, width * 0.6, height * 0.8);
            
            ctx.fillStyle = 'rgba(56, 189, 248, 0.6)';
            ctx.fillRect(width * 0.8, height * 0.1, width * 0.15, height * 0.8);
            
            ctx.fillStyle = 'rgba(255, 193, 7, 0.3)';
            ctx.fillRect(width * 0.35, height * 0.15, width * 0.3, height * 0.7);
            
            drawImpattElectricField(ctx, width, height, bias, voltage);
            
            ctx.fillStyle = '#1f2937';
            ctx.font = `bold ${Math.max(12, width * 0.018)}px Inter`;
            ctx.fillText('P⁺', width * 0.1, height * 0.96);
            ctx.fillText('Drift Region', width * 0.42, height * 0.96);
            ctx.fillText('N⁺', width * 0.85, height * 0.96);
            
            ctx.fillStyle = '#f59e0b';
            ctx.font = `bold ${Math.max(10, width * 0.015)}px Inter`;
            ctx.fillText('Multiplication Zone', width * 0.4, height * 0.05);
        }

        function drawImpattElectricField(ctx, width, height, bias, voltage) {
            const fieldStrength = Math.abs(voltage) / 50;
            const numLines = 10;
            const time = Date.now() * 0.003;
            
            for (let i = 0; i < numLines; i++) {
                const y = height * 0.2 + i * (height * 0.6) / numLines;
                const startX = width * 0.2;
                const endX = width * 0.8;
                
                const progress = i / numLines;
                const fieldProfile = 0.5 + 1.5 * Math.exp(-Math.pow((progress - 0.5) * 4, 2));
                const localField = fieldStrength * fieldProfile;
                
                const phase = time + i * 0.15;
                const intensity = 0.4 + 0.4 * localField + 0.2 * Math.sin(phase);
                
                ctx.strokeStyle = `rgba(255, 193, 7, ${intensity})`;
                ctx.lineWidth = 1 + localField * 2;
                
                ctx.beginPath();
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
                ctx.stroke();
                
                const numArrows = 5;
                for (let j = 0; j < numArrows; j++) {
                    const arrowX = startX + (j + 1) * (endX - startX) / (numArrows + 1);
                    const arrowSize = 6 + localField * 4;
                    const arrowAlpha = intensity;
                    
                    ctx.fillStyle = `rgba(255, 193, 7, ${arrowAlpha})`;
                    ctx.beginPath();
                    ctx.moveTo(arrowX, y);
                    ctx.lineTo(arrowX - arrowSize, y - arrowSize/2);
                    ctx.lineTo(arrowX - arrowSize, y + arrowSize/2);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }

        function updateAvalanchePhysics(time, bias, current, width, height) {
            const fieldStrength = bias / 30;
            const multiplicationZone = { 
                left: width * 0.35, 
                right: width * 0.65, 
                top: height * 0.2, 
                bottom: height * 0.8 
            };
            
            avalancheParticles.forEach((particle, index) => {
                particle.age += 0.015;
                
                const baseVelocity = (1.5 + fieldStrength) * width * 0.002;
                
                if (particle.type === 'electron') {
                    particle.vx = baseVelocity * (1 + Math.sin(time + particle.phase) * 0.3);
                    particle.vy = Math.sin(time * 1.5 + particle.phase) * height * 0.001;
                    particle.energy += fieldStrength * 0.008;
                } else if (particle.type === 'hole') {
                    particle.vx = -baseVelocity * 0.7;
                    particle.vy = Math.sin(time + particle.phase) * height * 0.0008;
                    particle.energy += fieldStrength * 0.005;
                }
                
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                const inMultiplicationZone = (
                    particle.x >= multiplicationZone.left && 
                    particle.x <= multiplicationZone.right &&
                    particle.y >= multiplicationZone.top && 
                    particle.y <= multiplicationZone.bottom
                );
                
                if (inMultiplicationZone && particle.energy > 0.4 && Math.random() < 0.025) {
                    createImpactIonizationEvent(particle, time);
                    particle.energy = 0.1;
                }
                
                if (particle.x < 0 || particle.x > width || particle.age > 8) {
                    avalancheParticles.splice(index, 1);
                }
                
                if (particle.y < height * 0.15) particle.y = height * 0.15;
                if (particle.y > height * 0.85) particle.y = height * 0.85;
            });
            
            impactEvents = impactEvents.filter(event => (time - event.time) < 3);
            
            if (Math.random() < 0.02 && avalancheParticles.length < 150) {
                addSeedParticle(width, height);
            }
        }

        function createImpactIonizationEvent(particle, time) {
            impactEvents.push({
                x: particle.x,
                y: particle.y,
                time: time,
                intensity: particle.energy,
                generation: particle.generation
            });
            
            if (avalancheParticles.length < 120) {
                const offset = 15;
                
                avalancheParticles.push({
                    type: 'electron',
                    x: particle.x + (Math.random() - 0.5) * offset,
                    y: particle.y + (Math.random() - 0.5) * offset,
                    vx: 0,
                    vy: 0,
                    energy: 0.15 + Math.random() * 0.2,
                    age: 0,
                    generation: particle.generation + 1,
                    size: 3 + Math.random(),
                    opacity: 0.8,
                    phase: Math.random() * Math.PI * 2
                });
                
                avalancheParticles.push({
                    type: 'hole',
                    x: particle.x + (Math.random() - 0.5) * offset,
                    y: particle.y + (Math.random() - 0.5) * offset,
                    vx: 0,
                    vy: 0,
                    energy: 0.1 + Math.random() * 0.15,
                    age: 0,
                    generation: particle.generation + 1,
                    size: 4 + Math.random(),
                    opacity: 0.7,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }

        function addSeedParticle(width, height) {
            avalancheParticles.push({
                type: Math.random() < 0.7 ? 'electron' : 'hole',
                x: width * 0.25 + Math.random() * width * 0.1,
                y: height * 0.3 + Math.random() * height * 0.4,
                vx: 0,
                vy: 0,
                energy: 0.2 + Math.random() * 0.2,
                age: 0,
                generation: 1,
                size: 3 + Math.random(),
                opacity: 0.8,
                phase: Math.random() * Math.PI * 2
            });
        }

        function drawAvalancheElements(ctx, width, height, time) {
            impactEvents.forEach(event => {
                const age = time - event.time;
                const maxAge = 3;
                const progress = age / maxAge;
                
                if (progress < 1) {
                    const radius = (1 - progress) * 30 * event.intensity;
                    const opacity = (1 - progress) * 0.9;
                    
                    const burstGradient = ctx.createRadialGradient(
                        event.x, event.y, 0,
                        event.x, event.y, radius
                    );
                    burstGradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                    burstGradient.addColorStop(0.4, `rgba(255, 193, 7, ${opacity * 0.8})`);
                    burstGradient.addColorStop(1, `rgba(255, 107, 107, 0)`);
                    
                    ctx.fillStyle = burstGradient;
                    ctx.beginPath();
                    ctx.arc(event.x, event.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(event.x - radius/2, event.y);
                    ctx.lineTo(event.x + radius/2, event.y);
                    ctx.moveTo(event.x, event.y - radius/2);
                    ctx.lineTo(event.x, event.y + radius/2);
                    ctx.stroke();
                }
            });
            
            avalancheParticles.forEach(particle => {
                const glowRadius = particle.size + particle.energy * 15;
                
                const gradient = ctx.createRadialGradient(
                    particle.x, particle.y, 0,
                    particle.x, particle.y, glowRadius
                );
                
                if (particle.type === 'electron') {
                    gradient.addColorStop(0, `rgba(34, 197, 94, ${particle.opacity})`);
                    gradient.addColorStop(1, 'rgba(34, 197, 94, 0)');
                } else {
                    gradient.addColorStop(0, `rgba(59, 130, 246, ${particle.opacity})`);
                    gradient.addColorStop(1, 'rgba(59, 130, 246, 0)');
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, glowRadius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = particle.type === 'electron' ? '#22c55e' : '#3b82f6';
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = `bold ${Math.max(6, particle.size)}px Inter`;
                ctx.textAlign = 'center';
                ctx.fillText(
                    particle.type === 'electron' ? '−' : '+',
                    particle.x, particle.y + 2
                );
                
                if (particle.generation > 2) {
                    ctx.fillStyle = 'rgba(255, 193, 7, 0.9)';
                    ctx.font = `${Math.max(6, width * 0.008)}px Inter`;
                    ctx.fillText(
                        `G${particle.generation}`, 
                        particle.x + particle.size + 5, 
                        particle.y - particle.size - 2
                    );
                }
            });
        }

        function drawImpattInformation(ctx, width, height, bias, current) {
            const M = 1 + Math.max(0, (bias - 20) / 10);
            ctx.fillStyle = '#f59e0b';
            ctx.font = `bold ${Math.max(12, width * 0.018)}px Inter`;
            ctx.fillText(`Multiplication: M = ${M.toFixed(1)}`, width * 0.10, height * 0.06);
            
            ctx.fillStyle = '#1f2937';
            ctx.font = `${Math.max(11, width * 0.016)}px Inter`;
            ctx.fillText(`Active Carriers: ${avalancheParticles.length}`, width * 0.10, height * 0.1);
            ctx.fillText(`Impact Events: ${impactEvents.length}`, width * 0.10, height * 0.14);
            
            ctx.fillStyle = '#3b82f6';
            ctx.font = `bold ${Math.max(11, width * 0.016)}px Inter`;
            ctx.fillText(`Current: ${current.toFixed(1)} mA`, width * 0.7, height * 0.06);
            
            const legendItems = [
                { color: '#22c55e', symbol: '−', label: 'Electrons' },
                { color: '#3b82f6', symbol: '+', label: 'Holes' },
                { color: '#fbbf24', symbol: '✦', label: 'Impact Ionization' }
            ];
            
            legendItems.forEach((item, i) => {
                const x = width * 0.7;
                const y = height * 0.1 + i * height * 0.04;
                
                ctx.fillStyle = item.color;
                ctx.font = `bold ${Math.max(10, width * 0.015)}px Inter`;
                ctx.fillText(`${item.symbol} ${item.label}`, x, y);
            });
        }

        function updateImpattCharts(timeData, currentData, voltageData, freq) {
            const currentTrace = {
                x: [...timeData],
                y: [...currentData],
                type: 'scatter',
                mode: 'lines',
                name: 'Current',
                line: { color: '#3b82f6', width: 2 },
                yaxis: 'y'
            };
            
            const voltageTrace = {
                x: [...timeData],
                y: [...voltageData],
                type: 'scatter',
                mode: 'lines',
                name: 'Voltage',
                line: { color: '#ef4444', width: 2 },
                yaxis: 'y2'
            };
            
            const layout = {
                title: 'IMPATT Current and Voltage Oscillations',
                xaxis: { title: 'Time (ns)' },
                yaxis: { title: 'Current (mA)', side: 'left' },
                yaxis2: {
                    title: 'Voltage (V)',
                    side: 'right',
                    overlaying: 'y'
                }
            };
            
            Plotly.react('impattTimeChart', [currentTrace, voltageTrace], layout);
            
            updatePowerSpectrum(timeData, currentData, freq);
        }

        function updatePowerSpectrum(timeData, currentData, freq) {
            if (currentData.length < 100) return;
            
            const frequencies = [];
            const power = [];
            
            for (let f = 0.1; f <= 50; f += 0.1) {
                frequencies.push(f);
                
                let amplitude = -80;
                
                if (Math.abs(f - freq) < 0.2) {
                    amplitude = -15 + 10 * Math.exp(-Math.pow((f - freq) / 0.1, 2));
                }
                else if (Math.abs(f - 2 * freq) < 0.3) {
                    amplitude = -35 + 8 * Math.exp(-Math.pow((f - 2 * freq) / 0.15, 2));
                }
                else if (Math.abs(f - 3 * freq) < 0.4) {
                    amplitude = -45 + 6 * Math.exp(-Math.pow((f - 3 * freq) / 0.2, 2));
                }
                else {
                    amplitude += 10 * Math.log10(freq / f) + (Math.random() - 0.5) * 8;
                }
                
                power.push(amplitude);
            }
            
            const spectrumTrace = {
                x: frequencies,
                y: power,
                type: 'scatter',
                mode: 'lines',
                name: 'Power Spectrum',
                line: { color: '#8b5cf6', width: 2 },
                fill: 'tozeroy',
                fillcolor: 'rgba(139, 92, 246, 0.2)'
            };
            
            const peakTrace = {
                x: [freq],
                y: [-15],
                type: 'scatter',
                mode: 'markers',
                name: `Peak (${freq} GHz)`,
                marker: { 
                    color: '#ef4444', 
                    size: 8,
                    symbol: 'diamond'
                }
            };
            
            Plotly.react('impattSpectrumChart', [spectrumTrace, peakTrace]);
        }

        function updateImpattStatus(bias, current, voltage, freq) {
            const resistance = parseFloat(document.getElementById('loadResistance').value);
            
            const power = Math.pow(current * 0.001, 2) * resistance * 1000;
            const dcPower = bias * current * 0.001;
            const efficiency = dcPower > 0 ? (power / (dcPower * 1000)) * 100 : 0;
            
            const qFactor = 50 + 50 * Math.exp(-Math.abs(voltage) * 0.1);
            
            const phaseNoise = -70 - 10 * Math.log10(Math.max(1, qFactor));
            
            document.getElementById('impattPower').textContent = power.toFixed(0) + ' mW';
            document.getElementById('impattEfficiency').textContent = efficiency.toFixed(1) + ' %';
            document.getElementById('qFactor').textContent = qFactor.toFixed(0);
            document.getElementById('phaseNoise').textContent = phaseNoise.toFixed(0) + ' dBc';
        }

        function stopImpattOscillation() {
            isImpattRunning = false;
        }

        function initializeCalculations() {
            try {
                updateTunnelingCalculations();
            } catch (error) {
                console.log('Tunneling calculations not initialized:', error);
            }
            
            try {
                updateTransportCalculations();
            } catch (error) {
                console.log('Transport calculations not initialized:', error);
            }
            
            try {
                updateImpattCalculations();
            } catch (error) {
                console.log('IMPATT calculations not initialized:', error);
            }
        }

        setTimeout(initializeCalculations, 100);

        window.switchTab = switchTab;
        window.switchVisualization = switchVisualization;
        window.applyTunnelingPreset = applyTunnelingPreset;
        window.applyTransportPreset = applyTransportPreset;
        window.applyImpattPreset = applyImpattPreset;
        window.resetTunneling = resetTunneling;
        window.startTunnelingAnimation = startTunnelingAnimation;
        window.calculateTransmission = calculateTransmission;
        window.runTransportComparison = runTransportComparison;
        window.startCarrierDynamicsVisualization = startCarrierDynamicsVisualization;
        window.startImpattOscillation = startImpattOscillation;
        window.stopImpattOscillation = stopImpattOscillation;
        
        // Guided Tour functionality
        let tourActive = false;
        let currentTourStep = 0;
        
        // Tour step definitions
        const tourSteps = [
            {
                title: "Welcome to the Advanced Semiconductor Simulator",
                content: "This interactive simulator allows you to explore quantum tunneling, carrier transport mechanisms, and IMPATT diode dynamics in semiconductor devices. Let's take a guided tour to understand the different features.",
                element: null, // No specific element for the welcome message
                position: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' }
            },
            {
                title: "Navigation Tabs",
                content: "The simulator is organized into different tabs, each focusing on a specific aspect of semiconductor physics. Click on these tabs to switch between different simulations.",
                element: ".nav-tabs",
                position: { top: '120px', left: '50%', transform: 'translateX(-50%)' }
            },
            {
                title: "Quantum Tunneling Simulation",
                content: "This tab simulates quantum tunneling through potential barriers. You can adjust parameters like barrier height, width, and applied voltage to see how they affect tunneling probability.",
                element: "#quantum-tunneling",
                position: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' }
            },
            {
                title: "Barrier Controls",
                content: "Use these sliders to adjust the barrier properties. As you change these values, watch how the transmission probability and wave function visualization update in real-time.",
                element: "#barrier-controls",
                position: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' }
            },
            {
                title: "Visualization Options",
                content: "Switch between different visualization modes to see the energy band diagram, wave function, or probability density of electrons tunneling through the barrier.",
                element: ".visualization-controls",
                position: { top: '250px', right: '20%' }
            },
            {
                title: "Transmission Probability Chart",
                content: "This chart shows how the probability of electron tunneling varies with energy. Notice how the curve changes as you adjust the barrier parameters.",
                element: "#transmissionChart",
                position: { bottom: '30%', left: '30%' },
                // Adding a custom handler for this specific step
                customHighlight: true
            },
            {
                title: "Transport Comparison Tab",
                content: "Switch to this tab to compare different carrier transport mechanisms: tunneling, drift, and ballistic transport.",
                element: "[data-tab='transport-comparison']",
                position: { top: '120px', left: '40%' },
                action: () => switchTab(null, 'transport-comparison')
            },
            {
                title: "Transport Visualization",
                content: "This dynamic visualization shows how carriers move through semiconductor structures under different transport mechanisms. The animation highlights the different behaviors of tunneling, drift, and ballistic transport.",
                element: "#transport-visualization",
                position: { top: '300px', left: '30%' }
            },
            {
                title: "Transport Parameters",
                content: "Adjust these parameters to see how they affect carrier movement. You can change electric field strength, temperature, and mobility to explore different transport conditions.",
                element: "#transport-controls",
                position: { top: '300px', right: '20%' }
            },
            {
                title: "Transport Presets",
                content: "Use these preset buttons to quickly configure common scenarios: Fast Pulse, Slow Ramp, Step Response, and High Field. These set multiple parameters for you.",
                element: "#transport-comparison button[onclick^='applyTransportPreset']",
                position: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' }
            },
            {
                title: "Pulse Amplitude",
                content: "Controls the input voltage amplitude driving the device. Higher amplitude increases the electric field and can enhance drift and ballistic contributions.",
                element: "#pulseAmplitude",
                position: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' }
            },
            {
                title: "Rise Time",
                content: "Sets the input signal rise time. Faster edges excite higher-frequency dynamics and can emphasize ballistic transport effects.",
                element: "#riseTime",
                position: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' }
            },
            {
                title: "Device Length",
                content: "Defines the length of the active region. Shorter devices reduce scattering and favor ballistic transport; longer devices favor drift/diffusion.",
                element: "#deviceLength",
                position: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' }
            },
            {
                title: "Doping Level",
                content: "Controls carrier concentration (log scale). Higher doping increases conductivity but can alter scattering rates and transit behavior.",
                element: "#dopingLevel",
                position: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' }
            },
            {
                title: "Run Transport Simulation",
                content: "Click to compute and visualize the tunneling, drift, and ballistic current responses for the selected conditions.",
                element: "#transport-comparison button[onclick='runTransportComparison()']",
                position: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' }
            },
            {
                title: "Current Response Chart",
                content: "This chart compares current vs time for tunneling (green), drift (red), and ballistic (blue) mechanisms so you can see which dominates.",
                element: "#responseChart",
                position: { bottom: '30%', left: '30%' }
            },
            {
                title: "IMPATT Diode Dynamics",
                content: "Switch to this tab to explore the Impact Ionization Avalanche Transit Time (IMPATT) diode, a device used for high-frequency microwave generation.",
                element: "[data-tab='impatt-dynamics']",
                position: { top: '120px', right: '40%' },
                action: () => switchTab(null, 'impatt-dynamics')
            },
            {
                title: "IMPATT Animation",
                content: "This visualization shows the avalanche multiplication process and carrier transit that leads to microwave oscillations. The animation illustrates impact ionization events and the resulting current pulses.",
                element: "#impatt-visualization",
                position: { top: '300px', left: '30%' }
            },
            {
                title: "IMPATT Controls",
                content: "Adjust these parameters to explore how bias voltage, doping, and device dimensions affect the IMPATT diode's frequency response and power output.",
                element: "#impatt-controls",
                position: { top: '300px', right: '20%' }
            },
            {
                title: "IMPATT Bias Voltage",
                content: "Sets the reverse bias across the avalanche region. Higher bias strengthens the field, increasing impact ionization and enabling oscillation.",
                element: "#impattBias",
                position: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' }
            },
            {
                title: "Oscillation Frequency",
                content: "Target oscillation frequency (in GHz). This affects the transit-time condition and where peaks appear in the spectrum.",
                element: "#impattFreq",
                position: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' }
            },
            {
                title: "Drift Region Length",
                content: "Length of the drift region controls the phase delay between generation and collection, setting the negative resistance condition.",
                element: "#driftLength",
                position: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' }
            },
            {
                title: "Load Resistance",
                content: "External load affects extracted power and efficiency. It also influences quality factor and phase noise.",
                element: "#loadResistance",
                position: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' }
            },
            {
                title: "Start/Stop IMPATT Oscillation",
                content: "Use these controls to start the avalanche transit-time oscillation and observe time-domain waveforms and spectrum.",
                element: "#impatt-controls button[onclick='startImpattOscillation()']",
                position: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' }
            },
            {
                title: "IMPATT Time-Domain Waveforms",
                content: "Shows current (blue) and voltage (red) over time, revealing the oscillation build-up and steady-state behavior.",
                element: "#impattTimeChart",
                position: { bottom: '30%', left: '30%' }
            },
            {
                title: "IMPATT Frequency Spectrum",
                content: "Power spectral density with peaks near the set frequency and harmonics, illustrating microwave generation.",
                element: "#impattSpectrumChart",
                position: { bottom: '30%', left: '30%' }
            },
            {
                title: "IMPATT Output Charts",
                content: "These charts show the time-domain current/voltage waveforms and frequency spectrum of the IMPATT diode. They illustrate how the device generates high-frequency oscillations through the combined effects of avalanche multiplication and transit time delay.",
                element: "#impatt-charts",
                position: { bottom: '30%', left: '30%' }
            },
            {
                title: "Challenges Tab",
                content: "Once you're familiar with the simulations, test your understanding with interactive challenges. They include multiple choice questions, advanced concepts, and calculations related to semiconductor physics.",
                element: "[data-tab='challenges']",
                position: { top: '120px', right: '30%' },
                action: () => switchTab(null, 'challenges')
            },
            {
                title: "Challenge Questions",
                content: "Each challenge section focuses on different aspects of semiconductor transport. Complete them to test your understanding of quantum tunneling, carrier dynamics, and device physics.",
                element: ".challenge-container",
                position: { top: '300px', left: '40%' }
            },
            {
                title: "Tour Complete!",
                content: "You've completed the guided tour of the Advanced Semiconductor Diode Transport Simulator. Feel free to explore the different tabs and features on your own. Click on the floating tour button anytime if you need to revisit this guide.",
                element: null,
                position: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' }
            }
        ];
        
        function startGuidedTour() {
            tourActive = true;
            currentTourStep = 0;
            
            // Create a small notification about interaction
            const notification = document.createElement('div');
            notification.style.position = 'fixed';
            notification.style.bottom = '20px';
            notification.style.left = '20px';
            notification.style.background = 'rgba(16, 185, 129, 0.9)';
            notification.style.color = 'white';
            notification.style.padding = '10px 15px';
            notification.style.borderRadius = '8px';
            notification.style.zIndex = '10001';
            notification.style.fontSize = '14px';
            notification.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.1)';
            notification.innerHTML = '<i class="fas fa-info-circle"></i> Tip: You can interact with the simulator during the tour!';
            document.body.appendChild(notification);
            
            // Show tour overlay and popup
            document.getElementById('tourOverlay').classList.add('active');
            document.getElementById('tourPopup').classList.add('active');
            
            // Start with the first step
            showTourStep(currentTourStep);
            
            // Remove notification after 5 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transition = 'opacity 0.5s ease';
                setTimeout(() => document.body.removeChild(notification), 500);
            }, 5000);
        }
        
        function showTourStep(stepIndex) {
            const step = tourSteps[stepIndex];
            
            // Update tour popup content
            document.getElementById('tourStepNumber').textContent = stepIndex + 1;
            document.getElementById('tourTitle').textContent = step.title;
            document.getElementById('tourContent').textContent = step.content;
            
            // Update progress bar
            const progress = ((stepIndex + 1) / tourSteps.length) * 100;
            document.getElementById('tourProgressBar').style.width = `${progress}%`;
            
            // Handle spotlight
            const spotlight = document.getElementById('tourSpotlight');
            const popup = document.getElementById('tourPopup');
            
            if (step.element) {
                const element = document.querySelector(step.element);
                if (element) {
                    // Hide spotlight until we scroll to and measure the element
                    spotlight.style.display = 'none';

                    // Smooth scroll the element into view first
                    try { element.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' }); } catch (_) { element.scrollIntoView(); }

                    // Wait for smooth scrolling to complete before highlighting
                    setTimeout(() => {
                        const rect = element.getBoundingClientRect();
                            
                        // Compute spotlight with smart padding and minimum sizes for small targets
                        const isTransmissionChart = step.title === "Transmission Probability Chart" || step.element === '#transmissionChart' || step.customHighlight;
                        const isVisualizationControls = step.title === "Visualization Options" || step.element === '.visualization-controls';

                        let padding = 10;
                        if (isTransmissionChart) padding = 25; // larger chart padding
                        if (isVisualizationControls) padding = 14; // slightly larger to encompass buttons cleanly

                        let top = rect.top - padding;
                        let left = rect.left - padding;
                        let width = rect.width + padding * 2;
                        let height = rect.height + padding * 2;

                        
                        // Ensure a minimum size so the highlight is visible for small controls rows
                        const minW = isVisualizationControls ? 160 : 0;
                        const minH = isVisualizationControls ? 56 : 0;
                        if (width < minW) { left -= (minW - width) / 2; width = minW; }
                        if (height < minH) { top -= (minH - height) / 2; height = minH; }

                        spotlight.style.top = `${top}px`;
                        spotlight.style.left = `${left}px`;
                        spotlight.style.width = `${width}px`;
                        spotlight.style.height = `${height}px`;
                        spotlight.style.display = 'block';

                        // Position popup: respect explicit step.position if provided
                        if (step.position) {
                            popup.style.top = '';
                            popup.style.left = '';
                            popup.style.right = '';
                            popup.style.bottom = '';
                            popup.style.transform = '';
                            Object.assign(popup.style, step.position);
                        } else {
                            const windowHeight = window.innerHeight;
                            const windowWidth = window.innerWidth;
                            let popupTop, popupLeft;

                            if (rect.bottom + 300 < windowHeight) {
                                popupTop = rect.bottom + 20 + 'px';
                                popupLeft = (rect.left + rect.width/2) + 'px';
                                popup.style.transform = 'translateX(-50%)';
                            } else if (rect.right + 450 < windowWidth) {
                                popupTop = rect.top + 'px';
                                popupLeft = (rect.right + 20) + 'px';
                                popup.style.transform = 'none';
                            } else if (rect.left - 450 > 0) {
                                popupTop = rect.top + 'px';
                                popupLeft = (rect.left - 20) + 'px';
                                popup.style.transform = 'translateX(-100%)';
                            } else {
                                popupTop = (rect.top - 300) + 'px';
                                popupLeft = (rect.left + rect.width/2) + 'px';
                                popup.style.transform = 'translateX(-50%)';
                            }
                            popup.style.top = popupTop;
                            popup.style.left = popupLeft;
                        }

                        // If the step has an action, execute it slightly after positioning
                        if (step.action) setTimeout(() => step.action(), 250);
                    }, 800); // Wait 800ms for smooth scrolling to finish
                }
            } else {
                // No specific element to highlight
                spotlight.style.display = 'none';
                
                // Center the popup for general steps
                Object.assign(popup.style, step.position);
            }
            
            // Update button states
            document.getElementById('prevTourBtn').disabled = stepIndex === 0;
            const nextBtn = document.getElementById('nextTourBtn');
            if (stepIndex === tourSteps.length - 1) {
                nextBtn.textContent = 'Finish';
            } else {
                nextBtn.textContent = 'Next';
            }
        }
        
        function nextTourStep() {
            if (currentTourStep < tourSteps.length - 1) {
                currentTourStep++;
                showTourStep(currentTourStep);
            } else {
                // End of tour
                endTour();
            }
        }
        
        function prevTourStep() {
            if (currentTourStep > 0) {
                currentTourStep--;
                showTourStep(currentTourStep);
            }
        }
        
        function skipTour() {
            endTour();
        }
        
        function endTour() {
            tourActive = false;
            
            // Hide tour elements
            document.getElementById('tourOverlay').classList.remove('active');
            document.getElementById('tourPopup').classList.remove('active');
            
            // Reset tour step
            currentTourStep = 0;
            
            // Switch back to the first tab
            switchTab(null, 'quantum-tunneling');
        }
        
        // Add tour start function to window for button access
        window.startGuidedTour = startGuidedTour;
        window.nextTourStep = nextTourStep;
        window.prevTourStep = prevTourStep;
        window.skipTour = skipTour;
        
        // Fix for the tab navigation on initial load
        document.addEventListener('DOMContentLoaded', function() {
            // Add click event listeners to tab buttons to ensure proper event handling
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.addEventListener('click', function(e) {
                    const tabId = this.getAttribute('data-tab');
                    switchTab(e, tabId);
                });
            });
        });
    </script>
    
    <!-- Challenges Tab Script -->
    <script>
        // Global variables for challenges
        let challengeAnswers = {
            quiz: [],
            advanced: [],
            fillBlanks: [],
            calculations: []
        };

        let challengeStates = {
            1: false, // Quantum Tunneling Fundamentals
            2: false, // Advanced Semiconductor Transport
            3: false, // Complete the Concepts
            4: false  // Quantum Device Calculations
        };

        // Enhanced question bank with detailed explanations and hints
        const questionBank = {
            // MCQ questions for challenge 1
            quiz: [
                {
                    question: "Which physical phenomenon allows electrons to pass through potential barriers that would be forbidden in classical physics?",
                    options: ["Drift transport", "Quantum tunneling", "Diffusion transport", "Thermionic emission"],
                    answer: 1,
                    explanation: "Quantum tunneling is a quantum mechanical phenomenon where particles pass through a potential energy barrier that they classically could not surmount. This occurs due to the wave-like properties of particles at the quantum level, allowing them to penetrate barriers with a probability dependent on barrier height and width.",
                    hint: "Think about wave-particle duality in quantum mechanics and how it affects barrier penetration."
                },
                {
                    question: "The probability of quantum tunneling through a barrier decreases exponentially with:",
                    options: ["Decreased barrier width", "Increased barrier width", "Decreased electron energy", "Increased temperature"],
                    answer: 1,
                    explanation: "The tunneling probability decreases exponentially with increased barrier width. The transmission coefficient T ∝ e^(-2kL), where k is related to the barrier height and L is the barrier width. As L increases, the probability drops significantly.",
                    hint: "Consider how changing the distance particles need to tunnel would affect the probability."
                },
                {
                    question: "Which of the following devices relies primarily on quantum tunneling?",
                    options: ["MOSFET", "Tunnel diode", "IMPATT diode", "Bipolar junction transistor"],
                    answer: 1,
                    explanation: "Tunnel diodes (also called Esaki diodes) operate primarily through quantum tunneling. They exhibit negative differential resistance in part of their I-V characteristic due to the tunneling of electrons through a heavily doped p-n junction.",
                    hint: "This device was invented by Leo Esaki and exhibits negative differential resistance."
                },
                {
                    question: "What happens to the tunneling probability as the effective mass of electrons increases?",
                    options: ["Increases", "Decreases", "Remains unchanged", "First increases then decreases"],
                    answer: 1,
                    explanation: "As the effective mass of electrons increases, the tunneling probability decreases. This is because heavier particles have shorter de Broglie wavelengths, reducing their quantum mechanical penetration through barriers. Mathematically, the transmission coefficient contains the effective mass in the exponent, with T ∝ e^(-2L√(2m*(V₀-E)/ħ²)).",
                    hint: "Think about how the de Broglie wavelength relates to mass and its effect on quantum behavior."
                },
                {
                    question: "In semiconductor devices, the barrier height for tunneling is primarily determined by:",
                    options: ["Temperature only", "Band gap energy", "Doping concentration and applied bias", "Only the device thickness"],
                    answer: 2,
                    explanation: "The barrier height for tunneling in semiconductor devices is primarily determined by doping concentration and applied bias. Higher doping creates narrower depletion regions that favor tunneling. Applied bias can modify the effective barrier height by changing the band alignment between the two sides of the junction.",
                    hint: "Consider what factors affect the energy band diagram in a semiconductor junction."
                },
                {
                    question: "The WKB approximation is used in quantum tunneling calculations to:",
                    options: ["Exactly solve the Schrödinger equation", "Approximate the tunneling probability for arbitrary barrier shapes", "Calculate only temperature effects", "Model only drift transport"],
                    answer: 1,
                    explanation: "The Wentzel-Kramers-Brillouin (WKB) approximation is a semi-classical method used to approximate the tunneling probability through barriers of arbitrary shapes. It allows calculation of transmission coefficients for barriers that don't have analytical solutions to the Schrödinger equation.",
                    hint: "This mathematical technique deals with varying potential barriers rather than just rectangular ones."
                },
                {
                    question: "The tunneling current in a semiconductor junction is most sensitive to changes in:",
                    options: ["Temperature", "Junction area", "Barrier width", "Carrier lifetime"],
                    answer: 2,
                    explanation: "Tunneling current is most sensitive to changes in barrier width due to the exponential dependence of tunneling probability on width. Even a small change in the barrier width can result in orders of magnitude difference in tunneling current, following the relationship I ∝ e^(-2kd) where d is the barrier width.",
                    hint: "Look at the exponential term in the tunneling probability equation and identify which parameter has the strongest effect."
                },
                {
                    question: "Which of the following correctly describes resonant tunneling?",
                    options: ["Tunneling through multiple barriers in series", "Tunneling through a single thick barrier", "Tunneling when electron energy matches a quantum well state", "Tunneling at high temperatures"],
                    answer: 2,
                    explanation: "Resonant tunneling occurs when the energy of the incoming electron matches the energy level of a quantum well state between two barriers. This creates a resonance condition where the transmission probability approaches unity, even though tunneling through each individual barrier would be much lower.",
                    hint: "This phenomenon involves quantum wells and discrete energy levels between barriers."
                }
            ],
            
            // Advanced concept questions for challenge 2
            advanced: [
                {
                    question: "Which of the following statements correctly describes the relationship between drift and diffusion currents in semiconductor devices?",
                    options: [
                        "Drift current is always dominant in forward-biased junctions",
                        "Diffusion current is proportional to carrier concentration gradient",
                        "Drift and diffusion always flow in the same direction",
                        "Diffusion current can only exist in p-type semiconductors"
                    ],
                    answer: 1,
                    explanation: "Diffusion current is proportional to the carrier concentration gradient (∇n for electrons or ∇p for holes) as described by Fick's law. It flows from regions of high concentration to low concentration. The diffusion current density is given by J = qD∇n for electrons, where D is the diffusion coefficient.",
                    hint: "Think about how carriers move when there's a non-uniform distribution."
                },
                {
                    question: "The IMPATT diode generates microwave oscillations primarily through:",
                    options: [
                        "Tunneling current",
                        "Avalanche multiplication followed by transit-time delay",
                        "Surface acoustic waves",
                        "Direct band-to-band recombination"
                    ],
                    answer: 1,
                    explanation: "IMPATT (IMPact ionization Avalanche Transit Time) diodes generate microwave oscillations through a two-stage process: first, carriers are multiplied through impact ionization (avalanche), creating a current pulse. Then, these carriers transit through a drift region, causing a phase delay between voltage and current that results in negative resistance and sustains oscillations.",
                    hint: "The name of this device is an acronym that describes its operating mechanism."
                },
                {
                    question: "Hot carrier effects in semiconductor devices become significant when:",
                    options: [
                        "The device is operated at high temperatures",
                        "Carriers gain energy much faster than they can lose it to the lattice",
                        "The device is heavily doped",
                        "The carrier mobility is very low"
                    ],
                    answer: 1,
                    explanation: "Hot carrier effects become significant when carriers (electrons or holes) gain energy from high electric fields much faster than they can lose it to the lattice through scattering. This non-equilibrium condition leads to an effective carrier temperature higher than the lattice temperature, affecting mobility, velocity saturation, and potentially causing device degradation.",
                    hint: "Consider the energy balance between what carriers gain from electric fields versus what they lose to the crystal lattice."
                },
                {
                    question: "Velocity saturation in semiconductors occurs when:",
                    options: [
                        "Carrier velocity decreases with increasing electric field",
                        "Carrier velocity becomes independent of electric field at high field strengths",
                        "Carrier velocity increases exponentially with electric field",
                        "Carriers reach the speed of light"
                    ],
                    answer: 1,
                    explanation: "Velocity saturation occurs when carrier velocity becomes independent of electric field at high field strengths. While at low fields, velocity is proportional to electric field (v = μE), at high fields, carriers gain energy but lose it through increased scattering with optical phonons, causing velocity to plateau at a saturation value (typically ~10⁷ cm/s for electrons in silicon).",
                    hint: "Think about what happens to mobility and scattering rates as the electric field becomes very strong."
                },
                {
                    question: "The Einstein relation in semiconductors relates:",
                    options: [
                        "Effective mass and bandgap",
                        "Diffusion coefficient and mobility",
                        "Carrier lifetime and drift velocity",
                        "Fermi level and temperature"
                    ],
                    answer: 1,
                    explanation: "The Einstein relation relates the diffusion coefficient (D) to mobility (μ) through: D = μkT/q, where k is Boltzmann's constant, T is temperature, and q is elementary charge. This fundamental relationship stems from the fact that both diffusion and drift are manifestations of carrier random thermal motion, with drift being the biased version due to electric field.",
                    hint: "This relation connects two key transport parameters and includes thermal energy."
                },
                {
                    question: "In semiconductor devices, impact ionization is:",
                    options: [
                        "The process of carriers gaining energy from lattice vibrations",
                        "A high-energy carrier creating electron-hole pairs by collisions",
                        "The injection of carriers across a forward-biased junction",
                        "The trapping of carriers at interface states"
                    ],
                    answer: 1,
                    explanation: "Impact ionization is the process where a high-energy carrier (electron or hole) collides with a lattice atom and transfers enough energy to create an electron-hole pair. This process requires the carrier to have energy greater than the bandgap and is the basis for avalanche multiplication in devices like avalanche photodiodes and IMPATT diodes.",
                    hint: "This process is similar to what happens in a chain reaction and involves energetic collisions."
                },
                {
                    question: "The negative differential resistance in a tunnel diode occurs because:",
                    options: [
                        "The junction capacitance increases with voltage",
                        "The tunneling current decreases as states become unavailable with increasing bias",
                        "The series resistance increases with current",
                        "Carriers recombine more rapidly at higher voltages"
                    ],
                    answer: 1,
                    explanation: "Negative differential resistance in a tunnel diode occurs because the tunneling current decreases as states become unavailable with increasing bias. Initially, as voltage increases, band-to-band tunneling current increases. However, past a certain point, further increasing the voltage misaligns the filled states on one side with available states on the other, causing the current to decrease despite increasing voltage.",
                    hint: "Think about the alignment of energy bands and available states on both sides of the junction as bias changes."
                }
            ],
            
            // Fill in the blanks questions for challenge 3
            fillBlanks: [
                {
                    text: "In quantum mechanics, the transmission probability for electrons tunneling through a rectangular barrier is proportional to e^(-α·w), where w is the barrier width and α depends on the barrier __1__ and electron __2__.",
                    blanks: [
                        { id: 1, answer: "height", alternatives: ["energy", "potential"] },
                        { id: 2, answer: "energy", alternatives: ["mass", "velocity"] }
                    ],
                    explanation: "The transmission probability for quantum tunneling through a rectangular barrier is proportional to e^(-2kw), where k = √(2m(V₀-E)/ħ²), with V₀ being the barrier height, E the electron energy, m the electron mass, and ħ the reduced Planck constant. Thus, both barrier height and electron energy are critical parameters determining the tunneling probability.",
                    hint: "The exponent in the equation depends on both the potential barrier's magnitude and the particle's own energy."
                },
                {
                    text: "The __1__ effect occurs when a high electric field in the depletion region of a reverse-biased p-n junction causes electron-hole pairs to be generated through __2__ ionization, leading to a rapid increase in current.",
                    blanks: [
                        { id: 1, answer: "avalanche", alternatives: ["breakdown", "zener"] },
                        { id: 2, answer: "impact", alternatives: ["collision", "carrier"] }
                    ],
                    explanation: "The avalanche effect is a multiplication process where high-energy carriers (accelerated by strong electric fields) create additional electron-hole pairs through impact ionization. This causes a chain reaction or 'avalanche' of carriers, leading to breakdown in reverse-biased junctions when the field reaches a critical value.",
                    hint: "This multiplication process is named after a natural disaster involving snow, and occurs due to high-energy collisions."
                },
                {
                    text: "In IMPATT diodes, microwave oscillations are generated due to a __1__ phase shift between current and voltage caused by the combination of avalanche multiplication and __2__ time delay.",
                    blanks: [
                        { id: 1, answer: "180", alternatives: ["90", "phase"] },
                        { id: 2, answer: "transit", alternatives: ["drift", "carrier"] }
                    ],
                    explanation: "IMPATT (IMPact ionization Avalanche Transit Time) diodes generate microwaves through a 180° phase shift between current and voltage. This negative resistance behavior comes from two mechanisms: a 90° phase shift from avalanche multiplication, and another 90° shift from the transit time delay as carriers drift through the device, together creating the full 180° shift needed for oscillation.",
                    hint: "For oscillation to occur, the total phase shift must be half a full cycle, and the second part involves how long carriers take to move through a region."
                },
                {
                    text: "The quantum tunneling current in highly doped p-n junctions flows from __1__ to __2__ bands without carriers having to overcome the energy barrier.",
                    blanks: [
                        { id: 1, answer: "valence", alternatives: ["conduction", "donor"] },
                        { id: 2, answer: "conduction", alternatives: ["valence", "acceptor"] }
                    ],
                    explanation: "In heavily doped p-n junctions, quantum tunneling allows current to flow directly from the valence band on the p-side to the conduction band on the n-side. This band-to-band tunneling occurs when the depletion region is very narrow and band bending aligns filled states in the valence band with empty states in the conduction band, allowing electrons to tunnel without thermal excitation over the barrier.",
                    hint: "Electrons normally need to be excited from one band to another, but tunneling allows a direct path between the band where holes exist and the band where electrons conduct."
                },
                {
                    text: "The __1__ approximation allows estimation of tunneling probability through barriers with arbitrary shapes by dividing the barrier into thin segments where the potential can be considered __2__.",
                    blanks: [
                        { id: 1, answer: "WKB", alternatives: ["Wentzel-Kramers-Brillouin", "semi-classical"] },
                        { id: 2, answer: "constant", alternatives: ["uniform", "flat"] }
                    ],
                    explanation: "The WKB (Wentzel-Kramers-Brillouin) approximation is a semi-classical method that estimates tunneling probability through arbitrarily shaped barriers. It works by dividing the barrier into thin segments where the potential can be considered approximately constant, then integrating the effects across the entire barrier width.",
                    hint: "This approximation is named after three physicists and treats quantum problems with slowly varying parameters using a segmented approach."
                }
            ],
            
            // Numerical calculation problems for challenge 4
            calculations: [
                {
                    problem: "Calculate the tunneling probability through a 1 nm wide potential barrier with height 0.3 eV for electrons with energy 0.1 eV. Use the simplified formula T ≈ e^(-2κd), where κ = √(2m(V₀-E)/ħ²), m = 9.11×10^-31 kg, and ħ = 1.054×10^-34 J·s.",
                    answer: 0.037,
                    tolerance: 0.005,
                    explanation: "To calculate tunneling probability, we use T ≈ e^(-2κd), where κ = √(2m(V₀-E)/ħ²).\nGiven:\n- Barrier width d = 1 nm = 1×10^-9 m\n- Barrier height V₀ = 0.3 eV = 0.3 × 1.602×10^-19 J\n- Electron energy E = 0.1 eV = 0.1 × 1.602×10^-19 J\n- Electron mass m = 9.11×10^-31 kg\n- Reduced Planck constant ħ = 1.054×10^-34 J·s\n\nCalculating κ:\nκ = √(2×9.11×10^-31×(0.3-0.1)×1.602×10^-19 / (1.054×10^-34)²)\nκ = √(2×9.11×10^-31×0.2×1.602×10^-19 / 1.11×10^-68)\nκ = 5.64×10^9 m^-1\n\nThe tunneling probability is:\nT = e^(-2×5.64×10^9×1×10^-9) = e^(-11.28) ≈ 0.037 or 3.7%",
                    hint: "Remember to convert energy from eV to Joules before calculating, and pay attention to the barrier height minus the electron energy."
                },
                {
                    problem: "An IMPATT diode operates at 10 GHz. If the electron drift velocity in silicon is 10^5 m/s, calculate the required drift region length (in micrometers) for the optimal transit time phase shift.",
                    answer: 2.5,
                    tolerance: 0.1,
                    explanation: "For optimal IMPATT operation, the transit time through the drift region should produce a 90° phase shift.\nGiven:\n- Frequency f = 10 GHz = 10×10^9 Hz\n- Drift velocity v = 10^5 m/s\n\nThe period of one complete cycle is T = 1/f = 1/(10×10^9) = 10^-10 s.\nFor a 90° phase shift, we need transit time = T/4 = 10^-10/4 = 2.5×10^-11 s.\n\nThe drift length L = v × transit time = 10^5 × 2.5×10^-11 = 2.5×10^-6 m = 2.5 μm.",
                    hint: "The phase shift required for the transit time portion of an IMPATT diode is 90°, which is one-quarter of a full cycle period."
                },
                {
                    problem: "A quantum well has width 10 nm. Calculate the energy (in meV) of the first quantum state, assuming infinite potential barriers and an electron effective mass of 0.067m₀, where m₀ = 9.11×10^-31 kg. Use E₁ = (h²/8mL²), where h = 6.626×10^-34 J·s.",
                    answer: 56.2,
                    tolerance: 1,
                    explanation: "For a particle in an infinite potential well, the energy levels are given by E_n = (n²h²)/(8mL²).\nFor the first energy level (n=1):\nGiven:\n- Well width L = 10 nm = 10×10^-9 m\n- Effective mass m = 0.067 × 9.11×10^-31 = 6.10×10^-32 kg\n- Planck's constant h = 6.626×10^-34 J·s\n\nCalculating E₁:\nE₁ = (h²)/(8mL²) = (6.626×10^-34)²/(8 × 6.10×10^-32 × (10×10^-9)²)\nE₁ = 9.01×10^-21 J\n\nConverting to meV (1 eV = 1.602×10^-19 J):\nE₁ = 9.01×10^-21 / 1.602×10^-19 × 1000 = 56.2 meV",
                    hint: "The energy levels in a quantum well depend on the well width squared and inversely on the effective mass. Remember that the energy is quantized with n²."
                },
                {
                    problem: "A p-n junction has donor concentration N_D = 10^16 cm^-3 and acceptor concentration N_A = 10^15 cm^-3. Calculate the width of the depletion region (in μm) under 5V reverse bias at room temperature (300K). Use W = √(2ε(V_bi + V_R)(N_A + N_D)/(q·N_A·N_D)), where ε = 1.05×10^-10 F/m for silicon, q = 1.6×10^-19 C, and built-in potential V_bi = 0.7 V.",
                    answer: 2.38,
                    tolerance: 0.05,
                    explanation: "The depletion width W is given by W = √(2ε(V_bi + V_R)(N_A + N_D)/(q·N_A·N_D)).\nGiven:\n- Donor concentration N_D = 10^16 cm^-3 = 10^22 m^-3\n- Acceptor concentration N_A = 10^15 cm^-3 = 10^21 m^-3\n- Permittivity ε = 1.05×10^-10 F/m\n- Elementary charge q = 1.6×10^-19 C\n- Built-in potential V_bi = 0.7 V\n- Reverse bias V_R = 5 V\n\nCalculating W:\nW = √(2 × 1.05×10^-10 × (0.7 + 5) × (10^21 + 10^22)/(1.6×10^-19 × 10^21 × 10^22))\nW = √(2 × 1.05×10^-10 × 5.7 × 1.1×10^22/(1.6×10^-19 × 10^43))\nW = 2.38×10^-6 m = 2.38 μm",
                    hint: "Remember to convert concentrations to the same units (m^-3), and the total voltage affecting the depletion width is the sum of built-in potential and the applied reverse bias."
                },
                {
                    problem: "Calculate the peak electric field (in V/cm) at the metallurgical junction of a silicon p-n diode with NA = 10^17 cm^-3, ND = 10^16 cm^-3, and an applied reverse bias of 10V. Use E_max = (qN_A·N_D(V_bi + V_R))/(ε(N_A + N_D)), where ε = 1.05×10^-12 F/cm and V_bi = 0.7V.",
                    answer: 1.56e5,
                    tolerance: 0.1e5,
                    explanation: "The peak electric field at the metallurgical junction is given by E_max = (qN_A·N_D(V_bi + V_R))/(ε(N_A + N_D)).\nGiven:\n- Acceptor concentration N_A = 10^17 cm^-3\n- Donor concentration N_D = 10^16 cm^-3\n- Permittivity ε = 1.05×10^-12 F/cm\n- Elementary charge q = 1.6×10^-19 C\n- Built-in potential V_bi = 0.7 V\n- Reverse bias V_R = 10 V\n\nCalculating E_max:\nE_max = (1.6×10^-19 × 10^17 × 10^16 × (0.7 + 10))/(1.05×10^-12 × (10^17 + 10^16))\nE_max = (1.6×10^-19 × 10^33 × 10.7)/(1.05×10^-12 × 1.1×10^17)\nE_max = 1.56×10^5 V/cm",
                    hint: "The peak electric field occurs at the metallurgical junction and depends on the doping concentrations and total voltage across the junction."
                }
            ]
        };

        // Random question selection system
        let selectedQuestions = {
            quiz: [],
            advanced: [],
            fillBlanks: [],
            calculations: []
        };

        function selectRandomQuestions() {
            // Select questions randomly from each category
            selectedQuestions.quiz = getRandomItems(questionBank.quiz, 4);
            selectedQuestions.advanced = getRandomItems(questionBank.advanced, 4);
            selectedQuestions.fillBlanks = getRandomItems(questionBank.fillBlanks, 3);
            selectedQuestions.calculations = getRandomItems(questionBank.calculations, 2);
            
            // Initialize challenge answers arrays
            initializeChallengeAnswers();
        }

        function getRandomItems(array, count) {
            const shuffled = [...array].sort(() => 0.5 - Math.random());
            return shuffled.slice(0, count);
        }

        function initializeChallengeAnswers() {
            challengeAnswers.quiz = Array(selectedQuestions.quiz.length).fill(null);
            challengeAnswers.advanced = Array(selectedQuestions.advanced.length).fill(null);
            challengeAnswers.fillBlanks = selectedQuestions.fillBlanks.map(q => Array(q.blanks.length).fill(''));
            challengeAnswers.calculations = Array(selectedQuestions.calculations.length).fill('');
        }

        function selectRandomQuestions() {
            // Select questions randomly from each category
            selectedQuestions.quiz = getRandomItems(questionBank.quiz, 4);
            selectedQuestions.advanced = getRandomItems(questionBank.advanced, 4);
            selectedQuestions.fillBlanks = getRandomItems(questionBank.fillBlanks, 3);
            selectedQuestions.calculations = getRandomItems(questionBank.calculations, 2);
            
            // Initialize challenge answers arrays
            initializeChallengeAnswers();
        }

        function getRandomItems(array, count) {
            const shuffled = [...array].sort(() => 0.5 - Math.random());
            return shuffled.slice(0, count);
        }

        function initializeChallengeAnswers() {
            challengeAnswers.quiz = Array(selectedQuestions.quiz.length).fill(null);
            challengeAnswers.advanced = Array(selectedQuestions.advanced.length).fill(null);
            challengeAnswers.fillBlanks = selectedQuestions.fillBlanks.map(q => Array(q.blanks.length).fill(''));
            challengeAnswers.calculations = Array(selectedQuestions.calculations.length).fill('');
        }

        // Enhanced hint and explanation functions
        function showQuizHints(challengeNum) {
            let hintsContainer = document.getElementById(`challenge${challengeNum}-feedback`);
            hintsContainer.className = "challenge-feedback";
            hintsContainer.classList.add("active");
            
            let hints = "";
            selectedQuestions.quiz.forEach((q, i) => {
                hints += `<div class="challenge-hint active">
                    <strong>Question ${i+1}:</strong> ${q.hint}
                </div>`;
            });
            
            hintsContainer.innerHTML = hints;
            
            // Update hints used counter
            incrementHintsUsed();
        }

        function showAdvancedHints() {
            let hintsContainer = document.getElementById('challenge2-feedback');
            hintsContainer.className = "challenge-feedback";
            hintsContainer.classList.add("active");
            
            let hints = "";
            selectedQuestions.advanced.forEach((q, i) => {
                hints += `<div class="challenge-hint active">
                    <strong>Question ${i+1}:</strong> ${q.hint}
                </div>`;
            });
            
            hintsContainer.innerHTML = hints;
            
            // Update hints used counter
            incrementHintsUsed();
        }

        function showFillBlanksHint() {
            let hintsContainer = document.getElementById('challenge3-feedback');
            hintsContainer.className = "challenge-feedback";
            hintsContainer.classList.add("active");
            
            let hints = "";
            selectedQuestions.fillBlanks.forEach((q, i) => {
                hints += `<div class="challenge-hint active">
                    <strong>Statement ${i+1}:</strong> ${q.hint}
                </div>`;
            });
            
            hintsContainer.innerHTML = hints;
            
            // Update hints used counter
            incrementHintsUsed();
        }

        function showCalculationHint() {
            let hintsContainer = document.getElementById('challenge4-feedback');
            hintsContainer.className = "challenge-feedback";
            hintsContainer.classList.add("active");
            
            let hints = "";
            selectedQuestions.calculations.forEach((q, i) => {
                hints += `<div class="challenge-hint active">
                    <strong>Problem ${i+1}:</strong> ${q.hint}
                </div>`;
            });
            
            hintsContainer.innerHTML = hints;
            
            // Update hints used counter
            incrementHintsUsed();
        }

        function incrementHintsUsed() {
            hintsUsed++;
            document.getElementById('hintsUsedValue').textContent = hintsUsed;
        }

        // Enhanced answer checking with detailed explanations
        function checkQuizAnswers(challengeNum) {
            let correct = 0;
            let feedback = document.getElementById(`challenge${challengeNum}-feedback`);
            let allAnswered = !challengeAnswers.quiz.includes(null);
            
            if (!allAnswered) {
                feedback.className = "challenge-feedback error";
                feedback.innerHTML = "Please answer all questions before submitting.";
                return;
            }
            
            let feedbackHTML = "";
            
            selectedQuestions.quiz.forEach((q, i) => {
                if (challengeAnswers.quiz[i] === q.answer) {
                    correct++;
                    feedbackHTML += `<div class="explanation-panel active">
                        <div class="explanation-title"><i class="fas fa-check-circle"></i>Question ${i+1}: Correct!</div>
                        <div class="explanation-content">${q.explanation}</div>
                    </div>`;
                } else {
                    feedbackHTML += `<div class="explanation-panel active">
                        <div class="explanation-title"><i class="fas fa-times-circle"></i>Question ${i+1}: Incorrect</div>
                        <div class="explanation-content">
                            <div class="wrong-answer-explanation">
                                You selected "${q.options[challengeAnswers.quiz[i]]}", but the correct answer is "${q.options[q.answer]}".
                            </div>
                            ${q.explanation}
                        </div>
                    </div>`;
                }
            });
            
            // Add overall result
            let resultHTML = `<div class="challenge-feedback ${correct >= selectedQuestions.quiz.length * 0.75 ? 'success' : 'error'}">
                You got ${correct} out of ${selectedQuestions.quiz.length} questions correct.
            </div>`;
            
            feedback.className = "challenge-feedback active";
            feedback.innerHTML = resultHTML + feedbackHTML;
            
            // Mark challenge complete if score is high enough
            if (correct >= selectedQuestions.quiz.length * 0.75) {
                markChallengeComplete(challengeNum, correct);
            }
        }

        function checkAdvancedAnswers() {
            let correct = 0;
            let feedback = document.getElementById('challenge2-feedback');
            let allAnswered = !challengeAnswers.advanced.includes(null);
            
            if (!allAnswered) {
                feedback.className = "challenge-feedback error";
                feedback.innerHTML = "Please answer all questions before submitting.";
                return;
            }
            
            let feedbackHTML = "";
            
            selectedQuestions.advanced.forEach((q, i) => {
                if (challengeAnswers.advanced[i] === q.answer) {
                    correct++;
                    feedbackHTML += `<div class="explanation-panel active">
                        <div class="explanation-title"><i class="fas fa-check-circle"></i>Question ${i+1}: Correct!</div>
                        <div class="explanation-content">${q.explanation}</div>
                    </div>`;
                } else {
                    feedbackHTML += `<div class="explanation-panel active">
                        <div class="explanation-title"><i class="fas fa-times-circle"></i>Question ${i+1}: Incorrect</div>
                        <div class="explanation-content">
                            <div class="wrong-answer-explanation">
                                You selected "${q.options[challengeAnswers.advanced[i]]}", but the correct answer is "${q.options[q.answer]}".
                            </div>
                            ${q.explanation}
                        </div>
                    </div>`;
                }
            });
            
            // Add overall result
            let resultHTML = `<div class="challenge-feedback ${correct >= selectedQuestions.advanced.length * 0.75 ? 'success' : 'error'}">
                You got ${correct} out of ${selectedQuestions.advanced.length} questions correct.
            </div>`;
            
            feedback.className = "challenge-feedback active";
            feedback.innerHTML = resultHTML + feedbackHTML;
            
            // Mark challenge complete if score is high enough
            if (correct >= selectedQuestions.advanced.length * 0.75) {
                markChallengeComplete(2, correct);
            }
        }

        function checkFillBlanks() {
            let feedback = document.getElementById('challenge3-feedback');
            let totalBlanks = 0;
            let correctBlanks = 0;
            
            // Check if all blanks are filled
            let allFilled = true;
            for (let i = 0; i < challengeAnswers.fillBlanks.length; i++) {
                for (let j = 0; j < challengeAnswers.fillBlanks[i].length; j++) {
                    if (!challengeAnswers.fillBlanks[i][j].trim()) {
                        allFilled = false;
                        break;
                    }
                }
                if (!allFilled) break;
            }
            
            if (!allFilled) {
                feedback.className = "challenge-feedback error";
                feedback.innerHTML = "Please fill in all blanks before submitting.";
                return;
            }
            
            let feedbackHTML = "";
            
            selectedQuestions.fillBlanks.forEach((q, i) => {
                let statementCorrect = true;
                let statementResult = "";
                
                q.blanks.forEach((blank, j) => {
                    totalBlanks++;
                    
                    // Check if answer matches any of the acceptable answers (case insensitive)
                    const userAnswer = challengeAnswers.fillBlanks[i][j].toLowerCase().trim();
                    const correctAnswer = blank.answer.toLowerCase();
                    const alternatives = blank.alternatives.map(alt => alt.toLowerCase());
                    
                    const isCorrect = userAnswer === correctAnswer || alternatives.includes(userAnswer);
                    
                    if (isCorrect) {
                        correctBlanks++;
                        statementResult += `<div class="explanation-panel active">
                            <div class="explanation-title"><i class="fas fa-check-circle"></i>Blank ${j+1}: Correct!</div>
                            <div class="explanation-content">
                                You entered "${challengeAnswers.fillBlanks[i][j]}" which is correct.
                            </div>
                        </div>`;
                    } else {
                        statementCorrect = false;
                        statementResult += `<div class="explanation-panel active">
                            <div class="explanation-title"><i class="fas fa-times-circle"></i>Blank ${j+1}: Incorrect</div>
                            <div class="explanation-content">
                                <div class="wrong-answer-explanation">
                                    You entered "${challengeAnswers.fillBlanks[i][j]}", but the correct answer is "${blank.answer}".
                                </div>
                            </div>
                        </div>`;
                    }
                });
                
                feedbackHTML += `<div class="challenge-feedback ${statementCorrect ? 'success' : 'error'}">
                    <strong>Statement ${i+1}:</strong>
                    ${statementResult}
                    <div class="detailed-hint active">${q.explanation}</div>
                </div>`;
            });
            
            // Add overall result
            let resultHTML = `<div class="challenge-feedback ${correctBlanks >= totalBlanks * 0.75 ? 'success' : 'error'}">
                You got ${correctBlanks} out of ${totalBlanks} blanks correct.
            </div>`;
            
            feedback.className = "challenge-feedback active";
            feedback.innerHTML = resultHTML + feedbackHTML;
            
            // Mark challenge complete if score is high enough
            if (correctBlanks >= totalBlanks * 0.75) {
                markChallengeComplete(3, correctBlanks);
            }
        }

        function checkCalculations() {
            let feedback = document.getElementById('challenge4-feedback');
            let correct = 0;
            
            // Check if all calculations are filled
            let allFilled = true;
            for (let i = 0; i < challengeAnswers.calculations.length; i++) {
                if (!challengeAnswers.calculations[i].trim()) {
                    allFilled = false;
                    break;
                }
            }
            
            if (!allFilled) {
                feedback.className = "challenge-feedback error";
                feedback.innerHTML = "Please provide answers for all calculations before submitting.";
                return;
            }
            
            let feedbackHTML = "";
            
            selectedQuestions.calculations.forEach((q, i) => {
                const userAnswer = parseFloat(challengeAnswers.calculations[i]);
                const expectedAnswer = q.answer;
                const tolerance = q.tolerance || 0.01;
                
                const isCorrect = Math.abs(userAnswer - expectedAnswer) <= tolerance;
                
                if (isCorrect) {
                    correct++;
                    feedbackHTML += `<div class="explanation-panel active">
                        <div class="explanation-title"><i class="fas fa-check-circle"></i>Problem ${i+1}: Correct!</div>
                        <div class="explanation-content">
                            Your answer ${userAnswer} is within the acceptable range of ${expectedAnswer}±${tolerance}.
                            <div class="detailed-hint active">${q.explanation}</div>
                        </div>
                    </div>`;
                } else {
                    feedbackHTML += `<div class="explanation-panel active">
                        <div class="explanation-title"><i class="fas fa-times-circle"></i>Problem ${i+1}: Incorrect</div>
                        <div class="explanation-content">
                            <div class="wrong-answer-explanation">
                                Your answer ${userAnswer} is outside the acceptable range of ${expectedAnswer}±${tolerance}.
                            </div>
                            <div class="detailed-hint active">${q.explanation}</div>
                        </div>
                    </div>`;
                }
            });
            
            // Add overall result
            let resultHTML = `<div class="challenge-feedback ${correct >= selectedQuestions.calculations.length * 0.75 ? 'success' : 'error'}">
                You got ${correct} out of ${selectedQuestions.calculations.length} calculations correct.
            </div>`;
            
            feedback.className = "challenge-feedback active";
            feedback.innerHTML = resultHTML + feedbackHTML;
            
            // Mark challenge complete if score is high enough
            if (correct >= selectedQuestions.calculations.length * 0.75) {
                markChallengeComplete(4, correct);
            }
        }

        function markChallengeComplete(challengeNum, points) {
            if (!challengeStates[challengeNum]) {
                challengeStates[challengeNum] = true;
                challengesCompleted++;
                
                // Add to total score
                const maxPoints = challengeNum === 3 ? selectedQuestions.fillBlanks.reduce((acc, q) => acc + q.blanks.length, 0) : 
                    (challengeNum === 4 ? selectedQuestions.calculations.length * 2 : 
                    (challengeNum === 1 ? selectedQuestions.quiz.length : selectedQuestions.advanced.length));
                
                totalScore += Math.ceil((points / maxPoints) * 100);
                
                // Update UI
                document.getElementById('challengesCompletedValue').textContent = `${challengesCompleted}/4`;
                document.getElementById('totalScoreValue').textContent = totalScore;
                document.getElementById('totalProgressBar').style.width = `${(challengesCompleted / 4) * 100}%`;
                
                // Mark challenge section as completed
                document.getElementById(`challenge${challengeNum}`).classList.add('completed');
                
                // Check if all challenges are complete
                if (challengesCompleted === 4) {
                    showAllChallengesComplete(totalScore);
                }
            }
        }

        function resetChallenge(challengeNum) {
            const challengeContent = document.getElementById(`challenge${challengeNum}-content`);
            const challengeFeedback = document.getElementById(`challenge${challengeNum}-feedback`);
            
            // Reset feedback
            challengeFeedback.className = "challenge-feedback";
            challengeFeedback.innerHTML = "";
            
            // Reset challenge state if it was completed
            if (challengeStates[challengeNum]) {
                challengeStates[challengeNum] = false;
                challengesCompleted--;
                document.getElementById('challengesCompletedValue').textContent = `${challengesCompleted}/4`;
                document.getElementById('totalProgressBar').style.width = `${(challengesCompleted / 4) * 100}%`;
                document.getElementById(`challenge${challengeNum}`).classList.remove('completed');
            }
            
            // Regenerate the challenge content
            switch (challengeNum) {
                case 1:
                    // Reset MCQ answers
                    challengeAnswers.quiz = Array(selectedQuestions.quiz.length).fill(null);
                    generateChallengeContent(1);
                    break;
                case 2:
                    // Reset advanced concept answers
                    challengeAnswers.advanced = Array(selectedQuestions.advanced.length).fill(null);
                    generateChallengeContent(2);
                    break;
                case 3:
                    // Reset fill in the blanks
                    challengeAnswers.fillBlanks = selectedQuestions.fillBlanks.map(q => Array(q.blanks.length).fill(''));
                    generateChallengeContent(3);
                    break;
                case 4:
                    // Reset calculations
                    challengeAnswers.calculations = Array(selectedQuestions.calculations.length).fill('');
                    generateChallengeContent(4);
                    break;
            }
        }

        function resetAllChallenges() {
            // Reset all challenge states
            for (let i = 1; i <= 4; i++) {
                if (challengeStates[i]) {
                    challengeStates[i] = false;
                    document.getElementById(`challenge${i}`).classList.remove('completed');
                }
            }
            
            // Reset counters
            challengesCompleted = 0;
            totalScore = 0;
            hintsUsed = 0;
            
            // Update UI
            document.getElementById('challengesCompletedValue').textContent = `${challengesCompleted}/4`;
            document.getElementById('totalScoreValue').textContent = totalScore;
            document.getElementById('hintsUsedValue').textContent = hintsUsed;
            document.getElementById('totalProgressBar').style.width = `0%`;
            
            // Select new questions
            selectRandomQuestions();
            
            // Regenerate all challenges
            for (let i = 1; i <= 4; i++) {
                generateChallengeContent(i);
                
                // Reset feedback
                const feedback = document.getElementById(`challenge${i}-feedback`);
                feedback.className = "challenge-feedback";
                feedback.innerHTML = "";
            }
        }

        function showAllChallengesComplete(finalScore) {
            // Create a modal to show completion
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            modal.style.display = 'flex';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            modal.style.zIndex = '10000';
            
            const modalContent = document.createElement('div');
            modalContent.style.backgroundColor = 'white';
            modalContent.style.padding = '30px';
            modalContent.style.borderRadius = '16px';
            modalContent.style.maxWidth = '500px';
            modalContent.style.textAlign = 'center';
            modalContent.style.boxShadow = '0 20px 40px rgba(0, 0, 0, 0.3)';
            
            // Add confetti effect
            createConfetti(modalContent);
            
            // Add content
            modalContent.innerHTML = `
                <h2 style="font-size: 2rem; color: #6366f1; margin-bottom: 20px;">🎉 Congratulations! 🎉</h2>
                <p style="font-size: 1.2rem; margin-bottom: 15px;">You've completed all challenges!</p>
                <div style="background: #f0fdf4; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="color: #065f46; margin-bottom: 10px;">Your Results:</h3>
                    <p style="font-size: 1.5rem; font-weight: 700; color: #10b981;">Final Score: ${finalScore}</p>
                    <p>Challenges Completed: 4/4</p>
                    <p>Hints Used: ${hintsUsed}</p>
                </div>
                <button class="btn btn-primary" onclick="closeCompletionModal()" style="padding: 12px 24px; font-size: 1.1rem;">
                    Continue Learning
                </button>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Add global function to close modal
            window.closeCompletionModal = function() {
                document.body.removeChild(modal);
            };
        }

        function createConfetti(container) {
            // Create confetti effect
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.style.position = 'absolute';
                confetti.style.width = Math.random() * 10 + 5 + 'px';
                confetti.style.height = Math.random() * 10 + 5 + 'px';
                confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
                confetti.style.borderRadius = '50%';
                confetti.style.top = -20 + 'px';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.opacity = Math.random() + 0.5;
                confetti.style.pointerEvents = 'none';
                confetti.style.animation = `fall ${Math.random() * 3 + 2}s linear forwards, fadeOut 0.5s ${Math.random() * 3 + 1.5}s forwards`;
                container.appendChild(confetti);
            }
        }

        // Function to select an answer in MCQ
        function selectQuizAnswer(challengeNum, questionNum, answer, element) {
            // Remove selected class from all options in this question
            const questionContainer = element.parentElement;
            const options = questionContainer.querySelectorAll('.quiz-option');
            
            options.forEach(opt => {
                opt.classList.remove('selected');
            });
            
            // Add selected class to the clicked option
            element.classList.add('selected');
            
            // Store the answer
            if (challengeNum === 1) {
                challengeAnswers.quiz[questionNum - 1] = answer;
            } else if (challengeNum === 2) {
                challengeAnswers.advanced[questionNum - 1] = answer;
            }
        }

        // Function to handle input change in fill in the blanks
        function handleFillBlankInput(statementNum, blankNum, element) {
            challengeAnswers.fillBlanks[statementNum - 1][blankNum - 1] = element.value;
        }

        // Function to handle input change in calculations
        function handleCalculationInput(problemNum, element) {
            challengeAnswers.calculations[problemNum - 1] = element.value;
        }

        // Enhanced question generation with explanations
        function generateChallengeContent(challengeNum) {
            switch (challengeNum) {
                case 1:
                    generateQuizQuestions();
                    break;
                case 2:
                    generateAdvancedConcepts();
                    break;
                case 3:
                    generateFillInTheBlanks();
                    break;
                case 4:
                    generateCalculationChallenge();
                    break;
            }
        }

        function generateQuizQuestions() {
            const contentContainer = document.getElementById('challenge1-content');
            let questionsHTML = '';
            
            selectedQuestions.quiz.forEach((q, i) => {
                questionsHTML += `
                    <div class="quiz-question">
                        <h4>Q${i+1}: ${q.question}</h4>
                        <div class="quiz-options">`;
                
                q.options.forEach((option, j) => {
                    const isSelected = challengeAnswers.quiz[i] === j;
                    questionsHTML += `
                        <div class="quiz-option ${isSelected ? 'selected' : ''}" 
                            onclick="selectQuizAnswer(1, ${i+1}, ${j}, this)">
                            ${option}
                        </div>`;
                });
                
                questionsHTML += `
                        </div>
                    </div>`;
            });
            
            contentContainer.innerHTML = questionsHTML;
        }

        function generateAdvancedConcepts() {
            const contentContainer = document.getElementById('challenge2-content');
            let questionsHTML = '';
            
            selectedQuestions.advanced.forEach((q, i) => {
                questionsHTML += `
                    <div class="quiz-question">
                        <h4>Q${i+1}: ${q.question}</h4>
                        <div class="quiz-options">`;
                
                q.options.forEach((option, j) => {
                    const isSelected = challengeAnswers.advanced[i] === j;
                    questionsHTML += `
                        <div class="quiz-option ${isSelected ? 'selected' : ''}" 
                            onclick="selectQuizAnswer(2, ${i+1}, ${j}, this)">
                            ${option}
                        </div>`;
                });
                
                questionsHTML += `
                        </div>
                    </div>`;
            });
            
            contentContainer.innerHTML = questionsHTML;
        }

        function generateFillInTheBlanks() {
            const contentContainer = document.getElementById('challenge3-content');
            let statementsHTML = '';
            
            selectedQuestions.fillBlanks.forEach((q, i) => {
                let text = q.text;
                
                // Replace blanks with input fields
                q.blanks.forEach((blank, j) => {
                    const placeholder = `__${blank.id}__`;
                    const inputField = `<input type="text" class="fill-blank-input" 
                                            placeholder="Fill in..." 
                                            oninput="handleFillBlankInput(${i+1}, ${j+1}, this)" 
                                            value="${challengeAnswers.fillBlanks[i][j] || ''}">`;
                    text = text.replace(placeholder, inputField);
                });
                
                statementsHTML += `
                    <div class="fill-blank-container">
                        <p class="fill-blank-text">${text}</p>
                    </div>`;
            });
            
            contentContainer.innerHTML = statementsHTML;
        }

        function generateCalculationChallenge() {
            const contentContainer = document.getElementById('challenge4-content');
            let problemsHTML = '';
            
            selectedQuestions.calculations.forEach((q, i) => {
                problemsHTML += `
                    <div class="quiz-question">
                        <h4>Problem ${i+1}:</h4>
                        <p style="margin-bottom: 15px;">${q.problem}</p>
                        <div style="display: flex; align-items: center;">
                            <label style="margin-right: 10px; font-weight: 500;">Your Answer:</label>
                            <input type="number" step="0.001" class="fill-blank-input" 
                                style="width: 150px;" 
                                placeholder="Enter value..." 
                                oninput="handleCalculationInput(${i+1}, this)"
                                value="${challengeAnswers.calculations[i] || ''}">
                        </div>
                    </div>`;
            });
            
            contentContainer.innerHTML = problemsHTML;
        }

        // Initialize challenges when the page loads
        function initializeChallenges() {
            // Reset counters
            challengesCompleted = 0;
            totalScore = 0;
            hintsUsed = 0;
            
            // Select random questions
            selectRandomQuestions();
            
            // Generate challenge content
            for (let i = 1; i <= 4; i++) {
                generateChallengeContent(i);
            }
            
            // Initialize UI elements
            document.getElementById('challengesCompletedValue').textContent = `${challengesCompleted}/4`;
            document.getElementById('totalScoreValue').textContent = totalScore;
            document.getElementById('hintsUsedValue').textContent = hintsUsed;
            document.getElementById('totalProgressBar').style.width = `0%`;
        }
        
        // Initialize challenges only if they haven't been initialized yet
        function initializeChallengesIfNeeded() {
            // Check if questions have been selected
            if (selectedQuestions.quiz.length === 0) {
                initializeChallenges();
            }
        }

        // Global variables for tracking
        let challengesCompleted = 0;
        let totalScore = 0;
        let hintsUsed = 0;

        // Function to initialize challenges when the "Challenges" tab is clicked for the first time
        let challengesInitialized = false;
        function initializeChallengesIfNeeded() {
            if (!challengesInitialized) {
                initializeChallenges();
                challengesInitialized = true;
            }
        }

        // Add these functions to the window object
        window.selectQuizAnswer = selectQuizAnswer;
        window.handleFillBlankInput = handleFillBlankInput;
        window.handleCalculationInput = handleCalculationInput;
        window.checkQuizAnswers = checkQuizAnswers;
        window.showQuizHints = showQuizHints;
        window.checkAdvancedAnswers = checkAdvancedAnswers;
        window.showAdvancedHints = showAdvancedHints;
        window.checkFillBlanks = checkFillBlanks;
        window.showFillBlanksHint = showFillBlanksHint;
        window.checkCalculations = checkCalculations;
        window.showCalculationHint = showCalculationHint;
        window.resetChallenge = resetChallenge;
        window.resetAllChallenges = resetAllChallenges;
        window.closeCompletionModal = function() {}; // Will be overridden when needed
        window.initializeChallengesIfNeeded = initializeChallengesIfNeeded;
    </script>
    
    <style>
        /* Challenge Styles */
        .challenge-container {
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .challenge-section {
            margin-bottom: 40px;
            padding: 25px;
            border-radius: 12px;
            border: 2px solid #e5e7eb;
            transition: all 0.3s ease;
        }

        .challenge-section:hover {
            border-color: #6366f1;
            box-shadow: 0 4px 20px rgba(99, 102, 241, 0.1);
        }

        .challenge-section.completed {
            border-color: #10b981;
            background: #f0fdf4;
        }

        .challenge-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        .challenge-icon {
            width: 60px;
            height: 60px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            margin-right: 15px;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
        }

        .challenge-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0;
        }

        .challenge-description {
            color: #6b7280;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .quiz-question {
            background: #f8fafc;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #6366f1;
        }

        .quiz-question h4 {
            margin: 0 0 10px 0;
            color: #1f2937;
            font-size: 1rem;
        }

        .quiz-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .quiz-option {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            padding: 10px 15px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            font-weight: 500;
        }

        .quiz-option:hover {
            border-color: #6366f1;
            background: #f8fafc;
        }

        .quiz-option.selected {
            border-color: #6366f1;
            background: #eff6ff;
            color: #1e40af;
        }

        .quiz-option.correct {
            border-color: #10b981;
            background: #f0fdf4;
            color: #065f46;
        }

        .quiz-option.incorrect {
            border-color: #ef4444;
            background: #fef2f2;
            color: #991b1b;
        }

        .fill-blank-container {
            background: #f8fafc;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
            border-left: 4px solid #8b5cf6;
        }

        .fill-blank-text {
            font-size: 1rem;
            line-height: 2;
            color: #1f2937;
        }

        .fill-blank-input {
            display: inline-block;
            width: 120px;
            padding: 4px 8px;
            border: 2px solid #6366f1;
            border-radius: 4px;
            text-align: center;
            font-weight: 600;
            margin: 0 5px;
            background: white;
        }

        .fill-blank-input:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .fill-blank-input.correct {
            border-color: #10b981;
            background: #f0fdf4;
            color: #065f46;
        }

        .fill-blank-input.incorrect {
            border-color: #ef4444;
            background: #fef2f2;
            color: #991b1b;
        }

        .challenge-controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .challenge-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }

        .challenge-btn-primary {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
        }

        .challenge-btn-secondary {
            background: #f3f4f6;
            color: #374151;
            border: 2px solid #e5e7eb;
        }

        .challenge-btn:hover {
            transform: translateY(-2px);
        }

        .challenge-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .challenge-feedback {
            margin-top: 15px;
            padding: 10px 15px;
            border-radius: 6px;
            font-weight: 500;
            display: none;
        }

        .challenge-feedback.success {
            background: #f0fdf4;
            color: #065f46;
            border: 1px solid #10b981;
            display: block;
        }

        .challenge-feedback.error {
            background: #fef2f2;
            color: #991b1b;
            border: 1px solid #ef4444;
            display: block;
        }

        .challenge-feedback.active {
            display: block;
        }

        .challenge-progress {
            background: #f3f4f6;
            border-radius: 8px;
            height: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .challenge-progress-bar {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 8px;
        }

        .challenge-stats {
            display: flex;
            justify-content: space-around;
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: #6366f1;
        }

        .stat-label {
            color: #6b7280;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        /* Enhanced challenge feedback and hints */
        .challenge-hint {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 6px;
            padding: 12px;
            margin: 15px 0;
            font-size: 0.9rem;
            color: #92400e;
            display: none;
        }

        .challenge-hint.active {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        .explanation-panel {
            background: #f0f9ff;
            border: 1px solid #0284c7;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            display: none;
        }

        .explanation-panel.active {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        .explanation-title {
            font-weight: 600;
            color: #0c4a6e;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }

        .explanation-title i {
            margin-right: 8px;
        }

        .explanation-content {
            color: #075985;
            line-height: 1.5;
            font-size: 0.9rem;
        }

        .wrong-answer-explanation {
            background: #fef2f2;
            border: 1px solid #ef4444;
            border-radius: 6px;
            padding: 10px;
            margin-top: 8px;
            font-size: 0.85rem;
            color: #991b1b;
        }

        .detailed-hint {
            background: #f0fdf4;
            border: 1px solid #10b981;
            border-radius: 6px;
            padding: 12px;
            margin: 10px 0;
            font-size: 0.9rem;
            color: #065f46;
            display: none;
        }

        .detailed-hint.active {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fall {
            to {
                transform: translateY(500px);
            }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }

        .btn-danger:active {
            transform: translateY(0);
        }
        
        /* Tour Styles */
        .tour-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 9998;
            display: none;
            pointer-events: none;
        }

        .tour-overlay.active {
            display: block;
            animation: fadeIn 0.3s ease-out;
        }

        .tour-spotlight {
            position: absolute;
            background: transparent;
            border: 3px solid #3b82f6;
            border-radius: 8px;
            transition: all 0.5s ease;
            z-index: 9999;
            pointer-events: none;
            box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);
            animation: spotlight-pulse 2s ease-in-out infinite;
        }

        @keyframes spotlight-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); }
            50% { box-shadow: 0 0 0 15px rgba(59, 130, 246, 0); }
        }

        .tour-spotlight-secondary {
            position: absolute;
            background: transparent;
            border: 2px solid #8b5cf6;
            border-radius: 8px;
            transition: all 0.5s ease;
            z-index: 9999;
            pointer-events: none;
            box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.4);
            animation: secondary-pulse 2s ease-in-out infinite;
        }

        @keyframes secondary-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.7); }
            50% { box-shadow: 0 0 0 10px rgba(139, 92, 246, 0); }
        }

        .tour-popup {
            position: fixed;
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            min-width: 300px;
            max-width: 450px;
            transform: scale(0.8);
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: auto;
            max-height: 80vh;
            overflow-y: auto;
        }

        .tour-popup.active {
            transform: scale(1);
            opacity: 1;
        }

        .tour-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .tour-step-number {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            margin-right: 12px;
        }

        .tour-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0;
        }

        .tour-content {
            color: #4b5563;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .tour-challenge {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            border: 2px solid #f59e0b;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .tour-challenge-title {
            font-weight: 600;
            color: #92400e;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }

        .tour-challenge-title i {
            margin-right: 8px;
        }

        .tour-challenge-content {
            color: #78350f;
            font-size: 0.9rem;
        }

        .tour-progress {
            background: #f3f4f6;
            height: 6px;
            border-radius: 3px;
            margin: 15px 0;
            overflow: hidden;
        }

        .tour-progress-bar {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            height: 100%;
            transition: width 0.5s ease;
        }

        .tour-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }

        .tour-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tour-btn-primary {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
        }

        .tour-btn-secondary {
            background: #f3f4f6;
            color: #374151;
        }

        .tour-btn:hover {
            transform: translateY(-1px);
        }

        .tour-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .floating-button {
            position: fixed;
            width: 3.5rem;
            height: 3.5rem;
            border-radius: 50%;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        .floating-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 14px rgba(0,0,0,0.25);
        }

        .floating-button:active {
            transform: translateY(-1px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        .floating-button.tour {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            bottom: 2rem;
            right: 2rem;
        }
    </style>
    
    <!-- Tour Elements -->
    <div class="floating-button tour" onclick="startGuidedTour()">
        <i class="fas fa-route"></i>
    </div>
    
    <div class="tour-overlay" id="tourOverlay">
        <div class="tour-spotlight" id="tourSpotlight"></div>
        <div class="tour-spotlight-secondary" id="tourSpotlightSecondary" style="display: none;"></div>
    </div>

    <div class="tour-popup" id="tourPopup">
        <div class="tour-header">
            <div class="tour-step-number" id="tourStepNumber">1</div>
            <div class="tour-title" id="tourTitle">Welcome to the Tour</div>
        </div>
        <div class="tour-progress">
            <div class="tour-progress-bar" id="tourProgressBar" style="width: 0%"></div>
        </div>
        <div class="tour-content" id="tourContent">
            Let's explore the Advanced Semiconductor Diode Transport Simulator!
        </div>
        <div id="tourChallenge"></div>
        <div class="tour-controls">
            <button class="tour-btn tour-btn-secondary" onclick="prevTourStep()" id="prevTourBtn" disabled>Previous</button>
            <button class="tour-btn tour-btn-secondary" onclick="skipTour()">Skip Tour</button>
            <button class="tour-btn tour-btn-primary" onclick="nextTourStep()" id="nextTourBtn">Next</button>
        </div>
    </div>
<script src="../assets/js/iframeResize.js"></script>
        
        </body>
</html>